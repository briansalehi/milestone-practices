<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>String</title>
<!-- ajax -->
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-tomorrow.min.css'>
<!-- bootstrap -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
<!-- prims plugin styles -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autolinker/prism-autolinker.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/command-line/prism-command-line.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet">
<style>
a,
a:hover,
a:focus {
	text-decoration: none;
}

pre {
	margin-bottom: 1.3rem !important;
}

button.sticky {
	position: sticky;
	top: 1%;
}

img {
	max-width: -moz-available;
}
.dark-mode {
	background-color: black;
	color: #aaaaaa;
}

.dark-mode a {
	color: royalblue;
}

.dark-mode .list-group-item {
	background-color: #212529;
	color: #aaaaaa;
}

.btn {
	background-color: #f5f5f5;
	z-index: 1;
}

.dark-mode .btn {
	background-color: #212529;
}

.dark-mode .group-child {
	background-color: #3a3a3a !important;
}

.dark-mode a.list-group-item:focus,
.dark-mode a.list-group-item:hover,
.dark-mode button.list-group-item:focus,
.dark-mode button.list-group-item:hover {
	background-color: #555555;
	color: #bdc0c4;
}
.breadcrumb a,
.breadcrumb a:hover,
.breadcrumb a:focus {
	text-decoration: none;
}

.breadcrumb-item+.breadcrumb-item::before {
	content: '> ';
}

.dark-mode .breadcrumb {
	background-color: #212529;
}

.dark-mode .breadcrumb a {
	color: #bdc0c4;
}

.dark-mode .breadcrumb a:hover,
.dark-mode .breadcrumb a:focus {
	text-decoration: none;
	color: #777777;
}
.just-padding {
  padding: 15px;
}

a.list-group-item:focus,
a.list-group-item:hover,
button.list-group-item:focus,
button.list-group-item:hover {
	color: #555;
	text-decoration: none;
	background-color: #dfdfdf;
}

.group-child {
	background-color: #f0f0f0 !important;
}

.list-group.list-group-root {
  padding: 0;
  overflow: hidden;
}

.list-group.list-group-root .list-group {
  margin-bottom: 0;
}

.list-group.list-group-root .list-group-item {
  border-radius: 0;
  border-width: 1px 0 0 0;
}

.list-group.list-group-root > .list-group-item:first-child {
  border-top-width: 0;
}

.list-group.list-group-root > .list-group > .list-group-item {
  padding-left: 30px;
}

.list-group.list-group-root > .list-group > .list-group > .list-group-item {
  padding-left: 45px;
}

.list-group-item .glyphicon {
  margin-right: 5px;
}
.pager .top {
	float: center;
}

.dark-mode .page-link {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .page-link .disabled li > a {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .pager li > a,
.dark-mode .pager li > span {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .pager li > a:hover,
.dark-mode .pager li > a:focus,
.dark-mode .pager li > span:hover {
	background-color: #555555;
	color: #bdc0c4;
}

.dark-mode .pager .disabled a,
.dark-mode .pager .disabled a:hover,
.dark-mode .pager .disabled a:focus {
	color: #6c757d;
	background-color: #212529;
	border: 1px solid #616161;
}
/* prism overrides */
div.code-toolbar>.toolbar a,
div.code-toolbar>.toolbar button,
div.code-toolbar>.toolbar span {
	margin-left: 0.7rem;
}
h1:hover .anchor .octicon-link, h2:hover .anchor .octicon-link, h3:hover .anchor .octicon-link, h4:hover .anchor .octicon-link, h5:hover .anchor .octicon-link, h6:hover .anchor .octicon-link {
	visibility: visible;
}

h1:hover .anchor .octicon-link, h2:hover .anchor .octicon-link, h3:hover .anchor .octicon-link, h4:hover .anchor .octicon-link, h5:hover .anchor .octicon-link, h6:hover .anchor .octicon-link {
	visibility: visible;
}

h1 .octicon-link, h2 .octicon-link, h3 .octicon-link, h4 .octicon-link, h5 .octicon-link, h6 .octicon-link {
	color: var(--color-text-primary);
	visibility: hidden;
}

h1 .octicon-link, h2 .octicon-link, h3 .octicon-link, h4 .octicon-link, h5 .octicon-link, h6 .octicon-link {
	color: var(--color-text-primary);
	visibility: hidden;
}

.octicon {
    fill: currentColor;
}
</style>
</head>
<body class="container dark-mode">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 1" accesskey="1" href="/">Home</a></li>
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 2" accesskey="2" href="/8.0.html">C++</a></li>
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 3" accesskey="3" href="/8.5.0.html">Standard Template Library</a></li>
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 4" accesskey="4" href="/8.5.1.0.html">Sequential Containers</a></li>
<li class='breadcrumb-item active'>String</li>
</ol>
<button id='darkmode-icon' class='btn pull-right sticky' onclick='toggle_darkmode()' title='ALT + SHIFT + N' accesskey='N'>&#x1F315;</button>
<h2>
<a id="String" class="anchor" aria-hidden="true" href="#String">
String
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h2>
<p>The STL string classes <code>std::string</code> that models a character string and <code>std::wstring</code> that models a wide character string helps you in the following ways:</p>

<ul>
	<li>Reduces the effort of string creation and manipulation</li>
	<li>Increases the stability of the application being programmed by internally managing memory allocation details</li>
	<li>Features copy constructor and assignment operators that automatically ensure that member strings get correctly copied</li>
	<li>Supplies useful utility functions that help in truncating, finding, and erasing to name a few</li>
	<li>Lets you focus efforts on your applicationâ€™s primary requirements rather than on string manipulation details</li>
</ul>

<p>Both <code>std::string</code> and <code>std::wstring</code> are actually template specializations of the same class, namely <code>std::basic_string<T></code> for types <code>char</code> and <code>wchar_t</code>, respectively. When you have learned using one, you can use the same methods and operators on the other.</p>

<p>To use the STL string class, you must include the header <code>&lt;string&gt;</code>.</p>

<p>The <code>std::string</code> class features many overloaded constructors and therefore can be instantiated and initialized in many different ways.</p>

<pre class="language-cpp line-numbers">
	<code>
		const char* constCStyleString = "Hello String!";
		std::string strFromConst(constCStyleString);
		std::string strFromConst = constCStyleString;
		std::string str2("Hello String!");
		std::string str2Copy(str2);
	</code>
</pre>

You can also instruct the constructor of string to accept only the first n characters of the supplied input string:

<pre class="language-cpp">
	<code>
		// Initialize a string to the first 5 characters of another
		std::string strPartialCopy(constCStyleString, 5);
	</code>
</pre>

<p>You can also initialize a <code>std::string</code> to contain a specific number of instances of a particular character:</p>

<pre class="language-cpp">
	<code>
		// Initialize a string object to contain 10 'a's
		std::string strRepeatChars(10, 'a');
	</code>
</pre>

<p>The character contents of an <code>std::string</code> can be accessed via iterators or via an array-like syntax where the offset is supplied, using the subscript <code>operator[]</code>.</p>

<p>A C-style representation of the string can be obtained via member function <code>c_str()</code>.</p>

TODO: listing 16.2 code samples

<p>String concatenation can be achieved by using either the <code>operator+=</code> or the <code>append()</code> member function:</p>

<p>The <code>std::string</code> supplies a <code>find()</code> member function with a few overloaded versions that help find a character or a substring in a given string object.</p>

<pre class="language-cpp line-numbers">
	<code>
		// Find substring "day" in sampleStr, starting at position 0
		size_t charPos = sampleStr.find("day", 0);

		// Check if the substring was found, compare against string::npos
		if (charPos != string::npos)
			std::cout << "First instance of \"day\" was found at position " << charPos;
		else
			std::cout << "Substring not found." << std::endl;
	</code>
</pre>

TODO: also write the sample of finding all instances

<p>The <code>std::string</code> also features find functions such as <code>find_ first_of()</code>, <code>find_first_not_of()</code>, <code>find_last_of()</code>, and <code>find_last_not_of()</code> that assist the programmer in working with strings.</p>

<p>The STL string features a function called <code>erase()</code> that can erase a number of characters when given an offset position and count:</p>

<pre class="language-cpp line-numbers">
	<code>
		std::string sampleStr("Hello String! Wake up to a beautiful day!");
		sampleStr.erase(13, 28); // Hello String!
	</code>
</pre>

<p>A character when supplied with an iterator pointing to it:</p>

<pre class="language-cpp">
	<code>
		sampleStr.erase(iCharS); // iterator points to a specific character
	</code>
</pre>

<p>A number of characters given a range supplied by two iterators that bind the same:</p>

<pre class="language-cpp">
	<code>
		sampleStr.erase(sampleStr.begin(), sampleStr.end()); // erase from begin to end
	</code>
</pre>

<p>The string class also supplies a <code>clear()</code> function that effectively clears the internal buffer and resets the string object.</p>

<p><code>std::string</code> can be reversed easily using the generic algorithm <code>std::reverse()</code>:</p>

<pre class="language-cpp line-numbers">
	<code>
		std::string sampleStr("Hello String! We will reverse you!");
		reverse(sampleStr.begin(), sampleStr.end());
	</code>
</pre>

<p>String case conversion can be effected using the algorithm <code>std::transform()</code>, which applies a user-specified function to every element of a collection.</p>

TODO: code sample in listing 16.7

<p>The <code>std::string</code> class, as you have learned, is actually a specialization of the STL template class <code>std::basic_string&lt;T&gt;</code>. The template declaration of container class basic_string is as follows:</p>

<pre class="language-cpp">
	<code>
		template&lt;class _Elem,  class _Traits,  class _Ax&gt;
		class std::basic_string
	</code>
</pre>

<p>In this template definition, the parameter of utmost importance is the first one: <code>_Elem</code>.</p> 
<p>This is the type collected by the <code>basic_string</code> object. The <code>std::string</code> is therefore the template specialization of <code>basic_string</code> for <code>_Elem=char</code>, whereas the <code>std::wstring</code> is the template specialization of <code>basic_string</code> for <code>_Elem=wchar_t</code>.</p>

<p>In other words, the <code>std::string</code> class is defined as <code>typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt; string;</code></p>

<p>And the <code>std::wstring</code> class is defined as typedef <code>basic_string&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt;&gt; wstring;</code></p>

<p>So, all string features and functions studied so far are actually those supplied by <code>basic_string</code>, and are therefore also applicable to the <code>std::wstring</code> class.</p>

<p>C++14 compliant versions of the standard library support <code>operator""s</code> that convert the string contained within the quotes, in entirety, to a <code>std::basic_string&lt;t&gt;</code>.</p>

TODO: Listing 16.8 demonstrates

<p>C++14 introduces a literal <code>operator""s</code> in <code>std::chrono</code>, as seen here:</p>

<pre class="language-cpp">
	<code>
		std::chrono::seconds timeInSec(100s); // 100 seconds
		std::string timeinText = "100"s; // string "100"
	</code>
</pre>

<p>The former indicates time in seconds and is an integer literal, while the latter gives a <code>std::string</code>.</p>

<p><code>std::string</code> can be initialized by string literals, paranthesis and initialization list. String objects can also be assigned to each other, copy constructor and move constructor are set properly to handle such assignments.</p>

<pre class="language-cpp line-numbers">
	<code>
		std::string family = "C"; // initializing string by copy assignment operator
		std::string language(family); // initializing by copy constructor
		std::string postfix(2, '+'); // initialize by a character N times
		language.append(postfix); // string concatanation by append method
		std::cout << language << std::endl;
	</code>
</pre>

<p>Algorithms can be used on <code>std::string</code> to perform operations such as <a href="/cpp/stl/algorithms/transform">transforming</a>, <a href="/cpp/stl/algorithms/find">finding</a>, <a href="/cpp/stl/algorithms/sort">sorting</a>, <a href="/cpp/stl/algorithms/erase">truncating</a>, <a href="/cpp/stl/algorithms/replace">replacing</a>, <a href="/cpp/stl/algorithms/reverse">reversing</a> and <a href="/cpp/stl/algorithms/search">searching</a> which will be discussed later on <a href="/cpp/stl/algorithm">algorithms</a>.</p>

<p>One useful algorithm applied on strings are transformations:</p>

<pre class="language-cpp line-numbers">
	<code>
    std::string sample("AbCdEfGhIjK");
    std::cout << "original std::string: " << sample << std::endl;

    transform(sample.begin(), sample.end(), sample.begin(), ::toupper);
    std::cout << "converted to upper case: " << sample << std::endl;

    transform(sample.begin(), sample.end(), sample.begin(), ::tolower);
    std::cout << "converted to lower case: " << sample << std::endl;
	</code>
</pre>

<p>Operators are fully discussed in their own chapter <a href="/cpp/object-orientation/operators">operators</a>, but there is a little useful operator used with string objects, called <a href="/cpp/object-orientation/operators/string-literal-operator">string literal operator</a>.</p>  

<p>Notice that when you use <mark>\0</mark> character in a null terminated string (C-style string) you are actually breaking that string as they represent the end of strings.</p>  

<p>Actually this character is a part of special character list and they can be parsed in your string to do tasks or make signs in a string. To make special characters to look just as they are written, use <code>""s</code> operator at the end of a string literal.</p>
<hr />
<h3>
<a id="Source" class="anchor" aria-hidden="true" href="#Source">
Source
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h3>
  <cite>string.cxx</cite>
<pre class="line-numbers" >
<code class="language-cpp">
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        using namespace std::string_literals;
    
        std::string simple(&quot;This string would be truncated \0 here by NULL character&quot;);
        std::cout &lt;&lt; simple &lt;&lt; std::endl;
    
        // note the &quot;&quot;s literal operator at the end of string literal
        std::string complete(&quot;This string would not be truncated \0 here thanks to \&quot;\&quot;s literal operator&quot;s);
        std::cout &lt;&lt; complete &lt;&lt; std::endl;
    
        return 0;
    }
</code>
</pre>
<hr />
<h3>
<a id="Execution" class="anchor" aria-hidden="true" href="#Execution">
Execution
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h3>
<pre>
<code class="language-bash">
g++ -Wall -g -o ./string.o -c ./string.cxx
</code>
</pre>
<pre>
<code class="language-bash">
g++ -g -o ./string.bin ./string.o
</code>
</pre>
<pre>
<code class="language-bash">
./string.bin
</code>
</pre>
<hr />
<h3>
<a id="Output" class="anchor" aria-hidden="true" href="#Output">
Output
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h3>
<pre>
<code class="language-cpp">
This string would be truncated
This string would not be truncated  here thanks to ""s literal operator
</code>
</pre>
<hr />
<h3>
<a id="References" class="anchor" aria-hidden="true" href="#References">
References
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h3>
<ul class="list-group">
<li class='list-group-item'>Sam's Teach Yourself C++ in One Hour a Day, 8th Edition - Siddhartha Rao: chapter 27</li>
</ul>
<ul class="pager">
<li class="previous"><a title="Shortcut: ALT + SHIFT + B" accesskey="B" href="/cpp/stl/sequencial-containers">Previous Page</a></li>
<li class="top"><a title="Shortcut: ALT + SHIFT + T" accesskey="T" href="/">Home</a></li>
<li class="next"><a title="Shortcut: ALT + SHIFT + F" accesskey="F" href="/cpp/stl/sequencial-containers/array">Next Page</a></li>
</ul>
<script>
function darkmode() {
	var bodystyle = document.body;
	var icon = document.getElementById('darkmode-icon');
	const dark = sessionStorage.getItem('darkmode');

	if (dark === 'true' || dark == 'undefined') {
		bodystyle.classList.add("dark-mode");
		sessionStorage.setItem('darkmode', true);
		icon.innerHTML = '&#x1F312;';
	} else {
		sessionStorage.setItem('darkmode', false);
		bodystyle.classList.remove("dark-mode");
		icon.innerHTML = '&#x1F315;';
	}
}
darkmode();

function toggle_darkmode() {
	var bodystyle = document.body;
	var icon = document.getElementById('darkmode-icon');
	const dark = sessionStorage.getItem('darkmode');

	if (dark === 'true' || dark == 'undefined') {
		bodystyle.classList.remove("dark-mode");
		sessionStorage.setItem('darkmode', false);
		icon.innerHTML = '&#x1F315;';
	} else {
		sessionStorage.setItem('darkmode', true);
		bodystyle.classList.add("dark-mode");
		icon.innerHTML = '&#x1F312;';
	}
}
var current_position = 0;

function scrollDownListener() {
  window.addEventListener(
    "keydown",
    function(event) {
      if (event.key == "j") {
        var screen_height = window.screen.height / 4;
		current_position += screen_height;
        window.scrollTo({top: current_position, behavior: 'smooth'})
      }
    }
  )
}

function scrollUpListener() {
  window.addEventListener(
    "keydown",
    function(event) {
      if (event.key == "k") {
        var screen_height = window.screen.height / 4;
		current_position -= screen_height;
		if (current_position < 0) {
			current_position = 0;
		}
        window.scrollTo({top: current_position, behavior: 'smooth'})
      }
    }
  )
}

scrollDownListener()
scrollUpListener()
</script>
<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<!-- bootstrap -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
<!-- prism js -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/prism.min.js'></script>
<!-- prism plugins -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autolinker/prism-autolinker.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/command-line/prism-command-line.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/remove-initial-line-feed/prism-remove-initial-line-feed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/show-language/prism-show-language.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-c.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-cpp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-bash.min.js"></script>
<script>
$(function() {
  $('.list-group-item').on('click', function() {
    $('.glyphicon', this)
      .toggleClass('glyphicon-chevron-right')
      .toggleClass('glyphicon-chevron-down');
  });
});
</script>
</body>
</html>
