<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Auto Type Deduction</title>
<!-- ajax -->
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-tomorrow.min.css'>
<!-- bootstrap -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
<!-- prims plugin styles -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autolinker/prism-autolinker.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/command-line/prism-command-line.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-highlight/prism-line-highlight.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet">
<style>
img {
	padding-top: 20px;
	padding-bottom: 20px;
}

a,
a:hover,
a:focus {
	text-decoration: none;
}

pre {
	margin-bottom: 1.3rem !important;
}

img {
	max-width: -moz-available;
}

@media only screen and (min-width:720px) {
	.description {
		display: block;
		max-width: 60%;
		margin-left: auto;
		margin-right: auto;
		padding-bottom: 10px;
	}

    .img-responsive {
        max-width: 60%;
        margin-left: auto;
        margin-right: auto;
    }
}
.dark-mode {
	background-color: black;
	color: #aaaaaa;
}

.dark-mode a {
	color: royalblue;
}

.dark-mode .list-group-item {
	background-color: #212529;
	color: #aaaaaa;
}

.dark-mode .btn {
	background-color: #212529;
}

.dark-mode .btn:hover {
	color: #777777;
}

.dark-mode .dropdown-item {
	background-color: #3a3a3a !important;
	color: #aaaaaa;
}

.dark-mode .group-child {
	background-color: #3a3a3a !important;
}

.dark-mode a.list-group-item:focus,
.dark-mode a.list-group-item:hover,
.dark-mode button.list-group-item:focus,
.dark-mode button.list-group-item:hover {
	background-color: #555555;
	color: #bdc0c4;
}
.sticky {
	position: sticky !important;
	z-index: 1;
	top: 3%;
}

.btn {
	background-color: #f5f5f5;
	height: 40px;
	width: 40px;
	border-radius: 5px;
	text-align: center !important;
	font-size: 18px !important;
}

.dropbtn {
  font-size: 14px;
  border: none;
}

.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  z-index: 1;
}

.dropdown-content a {
  color: black;
  text-decoration: none;
  display: block;
}
.breadcrumb a,
.breadcrumb a:hover,
.breadcrumb a:focus {
	text-decoration: none;
}

.breadcrumb-item+.breadcrumb-item::before {
	content: '> ';
}

.dark-mode .breadcrumb {
	background-color: #212529;
}

.dark-mode .breadcrumb a {
	color: #bdc0c4;
}

.dark-mode .breadcrumb a:hover,
.dark-mode .breadcrumb a:focus {
	text-decoration: none;
	color: #777777;
}
.just-padding {
  padding: 15px;
}

a.list-group-item:focus,
a.list-group-item:hover,
button.list-group-item:focus,
button.list-group-item:hover {
	color: #555;
	text-decoration: none;
	background-color: #dfdfdf;
}

.group-child {
	background-color: #f0f0f0 !important;
}

.list-group.list-group-root {
  padding: 0;
  overflow: hidden;
}

.list-group.list-group-root .list-group {
  margin-bottom: 0;
}

.list-group.list-group-root .list-group-item {
  border-radius: 0;
  border-width: 1px 0 0 0;
}

.list-group.list-group-root > .list-group-item:first-child {
  border-top-width: 0;
}

.list-group.list-group-root > .list-group > .list-group-item {
  padding-left: 30px;
}

.list-group.list-group-root > .list-group > .list-group > .list-group-item {
  padding-left: 45px;
}

.list-group-item .glyphicon {
  margin-right: 5px;
}
.pager .top {
	float: center;
}

.dark-mode .page-link {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .page-link .disabled li > a {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .pager li > a,
.dark-mode .pager li > span {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .pager li > a:hover,
.dark-mode .pager li > a:focus,
.dark-mode .pager li > span:hover {
	background-color: #555555;
	color: #bdc0c4;
}

.dark-mode .pager .disabled a,
.dark-mode .pager .disabled a:hover,
.dark-mode .pager .disabled a:focus {
	color: #6c757d;
	background-color: #212529;
	border: 1px solid #616161;
}
/* prism overrides */
div.code-toolbar>.toolbar a,
div.code-toolbar>.toolbar button,
div.code-toolbar>.toolbar span {
	margin-left: 0.7rem;
}
h1:hover .anchor .octicon-link, h2:hover .anchor .octicon-link, h3:hover .anchor .octicon-link, h4:hover .anchor .octicon-link, h5:hover .anchor .octicon-link, h6:hover .anchor .octicon-link {
	visibility: visible;
}

h1:hover .anchor .octicon-link, h2:hover .anchor .octicon-link, h3:hover .anchor .octicon-link, h4:hover .anchor .octicon-link, h5:hover .anchor .octicon-link, h6:hover .anchor .octicon-link {
	visibility: visible;
}

h1 .octicon-link, h2 .octicon-link, h3 .octicon-link, h4 .octicon-link, h5 .octicon-link, h6 .octicon-link {
	color: var(--color-text-primary);
	visibility: hidden;
}

h1 .octicon-link, h2 .octicon-link, h3 .octicon-link, h4 .octicon-link, h5 .octicon-link, h6 .octicon-link {
	color: var(--color-text-primary);
	visibility: hidden;
}

.octicon {
    fill: currentColor;
}
</style>
</head>
<body class="container dark-mode">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 1" accesskey="1" href="/">Home</a></li>
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 2" accesskey="2" href="/6.0.html">C++</a></li>
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 3" accesskey="3" href="/6.1.0.html">Fundamentals</a></li>
<li class="breadcrumb-item"><a title="Shortcut: ALT + SHIFT + 4" accesskey="4" href="/6.1.2.0.html">Memory Objects</a></li>
<li class='breadcrumb-item active'>Auto Type Deduction</li>
</ol>
<div class="dropdown pull-right sticky">
  <button class="btn btn-secondary dropbtn" onclick="toggle_settings()" style="font-size: 18px;">
	  &#x2699;
  </button>
  <div class="dropdown-content" id="dropdown-content">
    <button id="darkmode-icon" class="btn dropdown-item" onclick="toggle_darkmode()" title="ALT + SHIFT + N" accesskey="N">&#x2600;</button>
    <button class="btn dropdown-item" onclick="zoominLetter()" title="ALT + SHIFT + I" accesskey="i"><span style="font-size: 10px;">A</span><span style="font-size: 18px;">A</span></button>
    <button class="btn dropdown-item" onclick="zoomoutLetter()" title="ALT + SHIFT + O" accesskey="o"><span style="font-size: 18px;">A</span><span style="font-size: 10px;">A</span></button>
    <button class="btn dropdown-item" onclick="defaultFontSize()" title="ALT + SHIFT + D" accesskey="d">&#x21ba;</button>
  </div>
</div>
<h2>
<a id="Auto-Type-Deduction" class="anchor" aria-hidden="true" href="#Auto-Type-Deduction">
Auto Type Deduction
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h2>
<div class="difficulty"><span style="float:left;">Difficulty:&nbsp;</span><div class="progress" style="width: 100px;"><div class="progress-bar bg-success" role="progressbar" style="width: 33%; background-color: #28a745 !important;" aria-valuenow="1" aria-valuemin="1" aria-valuemax="3">Basic</div></div></div>
<p><code>auto</code> type is a way to let compiler deduce a type and replace it in compile type. Using auto requires you to initialize the variable for the compiler that uses this initial value in deciding what the variable type can be. When you donâ€™t initialize a variable of type <code>auto</code>, you get a compile error.</p>

<pre class="language-cpp line-numbers" data-line="">
	<code>
		// types are deduced by compiler at compile time
		auto guess = true; // bool
		auto deduct = 3.1415; // double
	</code>
</pre>

<p>Consider using <code>auto</code> as a placeholder for the actual type in the following situations:</p>

<ul>
	<li>To declare local variables with the form <code>auto name = expression</code> when you do not want to commit to a specific type:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto i = 42; // int
			auto d = 42.5; // double
			auto s = "text"; // char const *
			auto v = { 1, 2, 3 }; // std::initializer_list&lt;int&gt;
		</code>
	</pre>

	<li>To declare local variables with the <code>auto name = type-id { expression }</code> form when you need to commit to a specific type:</li>	
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto b = new char[10]{ 0 }; // char*
			auto s1 = std::string {"text"}; // std::string
			auto v1 = std::vector&lt;int&gt; { 1, 2, 3 }; // std::vector<int>
			auto p = std::make_shared&lt;int&gt;(42); // std::shared_ptr<int>
		</code>
	</pre>

	<li>To declare named lambda functions, with the form <code>auto name = lambda-expression</code>, unless the lambda needs to be passed or returned to a function:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto upper = [](char const c) {return toupper(c); };
		</code>
	</pre>
	
	<li>To declare lambda parameters and return values:</li>	
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto add = [](auto const a, auto const b) {return a + b;};
		</code>
	</pre>

	<li>To declare a function return type when you don't want to commit to a specific type:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			template &lt;typename F, typename T&gt;
			auto apply(F&amp;&amp; f, T value) {  return f(value); }
		</code>
	</pre>
</ul>

<p>There are some important benefits of using the <code>auto</code> specifier instead of actual types; the following is a list of, perhaps, the most important ones:</p>

<ul>
	<li>It is not possible to leave a variable uninitialized. This is a common mistake that developers make when declaring variables specifying the actual type. However, this is not possible with <code>auto</code>, which requires an initialization of the variable in order to deduce the type.</li>

	<li>Using <code>auto</code> ensures that you always use the correct type and that implicit conversion will not occur. Consider the following example where we retrieve the size of a vector to a local variable. In the first case, the type of the variable is <code>int</code>, though the <code>size()</code> method returns <code>size_t</code>. This means an implicit conversion from <code>size_t</code> to <code>int</code> will occur. However, using <code>auto</code> for the type will deduce the correct type; that is, <code>size_t</code>:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto v = std::vector&lt;int&gt;{ 1, 2, 3 };
		</code>
	</pre>

	<li>It means less typing and less concern for actual types that we don't care about anyway. A very common case is with iterators, but there are many more. In the following example, in the first for loop, we explicitly use the type of the iterator. The second loop with the <code>auto</code> specifier looks simpler and saves you from typing and caring about actual types:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			std::map&lt;int, std::string&gt; m;
			for (std::map&lt;int, std::string&gt;::const_iterator  it = m.cbegin(); it != m.cend(); ++it)
			{ /*...*/ }

			for (auto it = m.cbegin(); it != m.cend(); ++it)
			{ /*...*/ }
		</code>
	</pre>

	<li>Declaring variables with <code>auto</code> provides a consistent coding style with the type always in the right-hand side. If you allocate objects dynamically, you need to write the type both on the left and right side of the assignment, for example, <code>int* p = new int(42)</code>. With <code>auto</code>, the type is specified only once on the right side.</li>
</ul>

<p>However, there are some gotchas when using <code>auto</code>:</p>

<ul>
	<li>The <code>auto</code> specifier is only a placeholder for the type, not for the <b>const</b>, <b>volatile</b> and <b>references</b> specifiers.</li>
	<pre class="language-cpp line-numbers" data-line="15">
		<code>
			#include &lt;iostream&gt>

			class foo
			{
			public:
				foo(int const x = 0) : x_{ x } {}
				int&amp; get() { return x_; }
			private:
				int x_;
			};

			int main()
			{
				foo f(42);
				auto x = f.get();
				x = 100;
				std::cout &lt;&lt; f.get() &lt;&lt; '\n'; // prints 42
				return 0;
			}
		</code>
	</pre>

	<li>It is not possible to use <code>auto</code> for types that are not moveable:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto ai = std::atomic&lt;int&gt;(42); // error
		</code>
	</pre>

	<li>It is not possible to use <code>auto</code> for multi-word types, such as <code>long long</code>, <code>long double</code>, or <code>struct foo</code>. However, in the first case, the possible workarounds are to use literals or type aliases; as for the second, using struct/class in that form is only supported in C++ for C compatibility and should be avoided anyway:</li>
	<pre class="language-cpp line-numbers" data-line="">
		<code>
			auto l1 = long long{ 42 }; // error using llong = long long;
			auto l2 = llong{ 42 }; // OK auto l3 = 42LL; // OK
		</code>
	</pre>

	<li>If you use the <code>auto</code> specifier but still need to know the type, you can do so in most IDEs by putting the cursor over a variable, for instance. If you leave the IDE, however, that is not possible anymore, and the only way to know the actual type is to deduce it yourself from the initialization expression, which could mean searching through the code for function return types.</li>
</ul>

<p>In C++11, <code>auto</code> can be used for declaring local variables and for the return type of a function with a trailing return type.</p>

<pre class="language-cpp line-numbers" data-line="2">
	<code>
		// C++11
		auto func1(int const i) -&gt; int { return 2*i; }
	</code>
</pre>

<p>In C++14, <code>auto</code> can be used for the return type of a function without specifying a trailing type and for parameter declarations in lambda expressions. Future standard versions are likely to expand the use of <code>auto</code> to even more cases.</p>

<pre class="language-cpp line-numbers" data-line="2">
	<code>
		// C++14
		auto func2(int const i) { return 2*i; }
	</code>
</pre>

<p>As mentioned earlier, <code>auto</code> does not retain const/volatile and reference qualifiers. This leads to problems with <code>auto</code> as a placeholder for the return type from a function.</p>

<pre class="language-cpp line-numbers" data-line="17,18">
	<code>
		class foo
		{
		public:
			foo(int const x = 0) : x_{ x } {}
			int&amp; get() { return x_; }
		private:
			int x_;
		};

		auto proxy_get(foo&amp; f)
		{
			return f.get();
		}

		int main()
		{
			auto f = foo{ 42 };
			auto&amp; x = proxy_get(f); // cannot convert from 'int' to 'int &amp;'
			return 0;
		}
	</code>
</pre>

<p>The solution to this problem in C++14 is <code>decltype(auto)</code>, which will correctly deduce the type:</p>

<pre class="language-cpp line-numbers" data-line="1,9">
	<code>
		decltype(auto) proxy_get(foo& f)
		{
			return f.get();
		}

		int main()
		{
			auto f = foo{ 42 };
			decltype(auto) x = proxy_get(f);
			return 0;
		}
	</code>
</pre>

<p>The last important case where <code>auto</code> can be used is with lambdas. As of C++14, both lambda return types and lambda parameter types can be <code>auto</code>.</p>

<pre class="language-cpp line-numbers" data-line="1,8,16,17">
	<code>
		auto ladd = [] (auto const a, auto const b)
		{
			return a + b;
		};

		struct {
			template&lt;typename T, typename U&gt;
			auto operator() (T const a, U const b) const
			{
				return a + b;
			}
		} L;

		int main()
		{
			auto i = ladd(40, 2); // 42
			auto s = L("forty"s, "two"s); // "fortytwo"s
			return 0;
		}
	</code>
</pre>
<hr />
<h3>
<a id="References" class="anchor" aria-hidden="true" href="#References">
References
<svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
<path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
</path>
</svg>
</a>
</h3>
<ul class="list-group">
<li class='list-group-item'>Modern C++ Programming Cookbook, 2nd Edition - Marius Bancila: <span style='color: red'> chapter 1</span></li>
<li class='list-group-item'>Professional C++, 4th Edition - Marc Gregoire: <span style='color: red'> chapter 1</span></li>
<li class='list-group-item'>Sam's Teach Yourself C++ in One Hour a Day, 8th Edition - Siddhartha Rao: <span style='color: red'> chapter 1</span></li>
</ul>
<ul class="pager">
<li class="previous"><a title="Shortcut: ALT + SHIFT + B" accesskey="B" href="/cpp/fundamentals/memory-objects/storage">Previous Page</a></li>
<li class="next"><a title="Shortcut: ALT + SHIFT + F" accesskey="F" href="/cpp/fundamentals/memory-objects/arguments">Next Page</a></li>
</ul>
<script>
function darkmode() {
	var bodystyle = document.body;
	var icon = document.getElementById('darkmode-icon');
	const dark = sessionStorage.getItem('darkmode');

	if (dark === 'true' || dark == 'undefined') {
		bodystyle.classList.add("dark-mode");
		sessionStorage.setItem('darkmode', true);
		icon.innerHTML = '&#x2600;';
	} else {
		sessionStorage.setItem('darkmode', false);
		bodystyle.classList.remove("dark-mode");
		icon.innerHTML = '&#x263d;';
	}
}
darkmode();

function toggle_darkmode() {
	var bodystyle = document.body;
	var icon = document.getElementById('darkmode-icon');
	const dark = sessionStorage.getItem('darkmode');

	if (dark === 'true' || dark == 'undefined') {
		bodystyle.classList.remove("dark-mode");
		sessionStorage.setItem('darkmode', false);
		icon.innerHTML = '&#x263d;';
		toggle_settings();
	} else {
		sessionStorage.setItem('darkmode', true);
		bodystyle.classList.add("dark-mode");
		icon.innerHTML = '&#x2600;';
		toggle_settings();
	}
}
var current_position = 0;

function scrollDownListener() {
  window.addEventListener(
    "keydown",
    function(event) {
      if (event.key == "j") {
        var screen_height = window.screen.height / 4;
		current_position += screen_height;
        window.scrollTo({top: current_position, behavior: 'smooth'})
      }
    }
  )
}

function scrollUpListener() {
  window.addEventListener(
    "keydown",
    function(event) {
      if (event.key == "k") {
        var screen_height = window.screen.height / 4;
		current_position -= screen_height;
		if (current_position < 0) {
			current_position = 0;
		}
        window.scrollTo({top: current_position, behavior: 'smooth'})
      }
    }
  )
}

scrollDownListener()
scrollUpListener()
function toggle_settings() {
	var button_list = document.getElementById('dropdown-content');

	if (button_list.style.display != "none") {
		button_list.style.display = "none";
	} else {
		button_list.style.display = "block";
	}
}
toggle_settings();
var min_level  = 1;
var max_level  = 12;
var fontlevel  = parseInt(localStorage.getItem('fontlevel'));
var fontsize   = parseInt(localStorage.getItem('fontsize'));
var h1fontsize = parseInt(localStorage.getItem('h1fontsize'));
var h2fontsize = parseInt(localStorage.getItem('h2fontsize'));
var h3fontsize = parseInt(localStorage.getItem('h3fontsize'));
var h4fontsize = parseInt(localStorage.getItem('h4fontsize'));

if (!fontlevel)  { fontlevel  =  3; localStorage.setItem('fontlevel', 3 ); }
if (!fontsize)   { fontsize   = 14; localStorage.setItem('fontsize',  14); }
if (!h1fontsize) { h1fontsize = 32; localStorage.setItem('h1fontsize',32); }
if (!h2fontsize) { h2fontsize = 24; localStorage.setItem('h2fontsize',24); }
if (!h3fontsize) { h3fontsize = 18; localStorage.setItem('h3fontsize',18); }
if (!h4fontsize) { h4fontsize = 16; localStorage.setItem('h4fontsize',16); }

function defaultFontSize() {
	fontlevel  =  3;
	fontsize   = 14;
	h1fontsize = 32;
	h2fontsize = 24;
	h3fontsize = 18;
	h4fontsize = 16;
	localStorage.setItem('fontlevel',  fontlevel );
	localStorage.setItem('fontsize',   fontsize  );
	localStorage.setItem('h1fontsize', h1fontsize);
	localStorage.setItem('h2fontsize', h2fontsize);
	localStorage.setItem('h3fontsize', h3fontsize);
	localStorage.setItem('h4fontsize', h3fontsize);

	restoreFontSize();
	document.getElementById('dropdown-content').style.display = 'none';
}

function zoominLetter() {
	if (fontlevel < max_level) {
		fontlevel += 1;
		fontsize += 2;
		h1fontsize += 2;
		h2fontsize += 2;
		h3fontsize += 2;
		h4fontsize += 2;

		localStorage.setItem('fontlevel', fontlevel);
		localStorage.setItem('fontsize', fontsize);
		localStorage.setItem('h1fontsize', h1fontsize);
		localStorage.setItem('h2fontsize', h2fontsize);
		localStorage.setItem('h3fontsize', h3fontsize);
		localStorage.setItem('h4fontsize', h4fontsize);

		restoreFontSize();
	}
}

function zoomoutLetter() {
	if (fontlevel > min_level) {
		fontlevel -= 1;
		fontsize -= 2;
		h1fontsize -= 2;
		h2fontsize -= 2;
		h3fontsize -= 2;
		h4fontsize -= 2;

		localStorage.setItem('fontlevel', fontlevel);
		localStorage.setItem('fontsize', fontsize);
		localStorage.setItem('h1fontsize', h1fontsize);
		localStorage.setItem('h2fontsize', h2fontsize);
		localStorage.setItem('h3fontsize', h3fontsize);
		localStorage.setItem('h4fontsize', h4fontsize);

		restoreFontSize();
	}
}

function restoreFontSize() {
	fontsize   = parseInt(localStorage.getItem('fontsize'));
	h1fontsize = parseInt(localStorage.getItem('h1fontsize'));
	h2fontsize = parseInt(localStorage.getItem('h2fontsize'));
	h3fontsize = parseInt(localStorage.getItem('h3fontsize'));
	h4fontsize = parseInt(localStorage.getItem('h4fontsize'));

	var p     = document.getElementsByTagName('p');
	var pre   = document.getElementsByTagName('pre');
	var ul    = document.getElementsByTagName('ul');
	var ol    = document.getElementsByTagName('ol');
	var table = document.getElementsByTagName('table');
	var cite  = document.getElementsByTagName('cite');
	var toc   = document.getElementsByClassName('list-group');
	var bar   = document.getElementsByClassName('difficulty');
	var h1    = document.getElementsByTagName('h1');
	var h2    = document.getElementsByTagName('h2');
	var h3    = document.getElementsByTagName('h3');
	var h4    = document.getElementsByTagName('h4');

	for(i=0 ; i<p.length ; i++) {
		p[i].style.fontSize     = fontsize+"px"
	}
	for(i=0;i<pre.length;i++) {
		pre[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<ul.length;i++) {
		ul[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<ol.length;i++) {
		ol[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<table.length;i++) {
		table[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<cite.length;i++) {
		cite[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<toc.length;i++) {
		toc[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<bar.length;i++) {
		bar[i].style.fontSize = fontsize+"px"
	}
	for(i=0;i<h1.length;i++) {
		h1[i].style.fontSize = h1fontsize+"px"
	}
	for(i=0;i<h2.length;i++) {
		h2[i].style.fontSize = h2fontsize+"px"
	}
	for(i=0;i<h3.length;i++) {
		h3[i].style.fontSize = h3fontsize+"px"
	}
	for(i=0;i<h4.length;i++) {
		h4[i].style.fontSize = h4fontsize+"px"
	}
}
restoreFontSize();
</script>
<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<!-- bootstrap -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
<!-- prism js -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/prism.min.js'></script>
<!-- prism plugins -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autolinker/prism-autolinker.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/command-line/prism-command-line.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/remove-initial-line-feed/prism-remove-initial-line-feed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/show-language/prism-show-language.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-c.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-cpp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-bash.min.js"></script>
<script>
$(function() {
  $('.list-group-item').on('click', function() {
    $('.glyphicon', this)
      .toggleClass('glyphicon-chevron-right')
      .toggleClass('glyphicon-chevron-down');
  });
});
</script>
</body>
</html>
