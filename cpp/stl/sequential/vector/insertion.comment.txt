<p>Insertion in a vector happens at the end of the array, and elements are “pushed” into its back using the member function <code>push_back()</code>:</p>

<pre class="language-cpp line-numbers">
	<code>
		// declare a vector of type int
		std::vector&lt;int&gt; integers;

		// Insert sample integers into the vector:
		integers.push_back(50);
		integers.push_back(1);

		std::cout &lt;&lt; integers.size() &lt;&lt; " Elements" &lt;&lt; std::endl;
	</code>
</pre>

<p>C++11 features initializer lists via class <code>std::initialize_list&lt;&gt;</code> that, when  supported, enables you to instantiate and initialize elements in a container like you would in a static array. <code>std::vector</code>, like most containers, supports List Initialization allowing you to instantiate a vector with elements in one line:</p>

<pre class="language-cpp line-numbers">
	<code>
		std::vector&lt;int&gt; integers = {50, 1, 987, 1001};
		// alternatively:
		std::vector&lt;int&gt; vecMoreIntegers{50, 1, 987, 1001};
	</code>
</pre>

<p>Many STL containers, including <code>std::vector</code>, feature an <code>insert()</code> function with many overloads.</p>

<pre class="language-cpp line-numbers">
	<code>
		// insert an element at the beginning
		integers.insert(integers.begin(), 25);

		// Insert 2 elements of value 45 at the end
		integers.insert(integers.end(), 2, 45);

		// Another vector containing 2 elements of value 30
		std::vector&lt;int&gt; another(2, 30);

		// Insert two elements from another container in position [1]
		integers.insert(integers.begin() + 1, another.begin(), another.end());
	</code>
</pre>

<p>Although <code>vector::insert()</code> is a versatile function, <code>push_back()</code> should be your preferred way of adding elements to a vector. This is because <code>insert()</code> is an inefficient way to add elements to the vector (when adding in a position that is not the end of the sequence) because adding elements in the beginning or the middle makes the vector class shift all subsequent elements backward (after making space for the last ones at the end). Thus, depending on the type of the objects contained in the sequence, the cost of this shift operation can be significant in terms of the copy constructor or copy assignment operator invoked. In our little sample, the vector contains objects of type <code>int</code> that are relatively inexpensive to move around. This might not be the case in many other uses of the <code>std::vector</code> class.</p>

<p>If your container needs to have very frequent insertions in the middle, you should ideally choose the <code>std::list</code></p>

<p>Elements in a <code>std::vector</code> can be accessed using the following methods:</p>

<ul>
	<li>via array semantics using the subscript <code>operator[]</code></li>
	<li>using the member function <code>at()</code>, or using iterators.</li>
</ul>

<p>Accessing elements in a <code>std::vector</code> using <code>operator[]</code> is fraught with the same dangers as accessing elements in an <code>array</code>; that is, you should not cross the bounds of the container. If you use the subscript <code>operator[]</code> to access elements in a <code>std::vector</code> at a position that is beyond its bounds, the result of the operation will be undefined (anything could happen, possibly an access violation).</p>

<p>A safer alternative is to use the <code>at()</code> member function:</p>

<p><code>at()</code> performs a runtime check against the <code>size()</code> of the container and throws an exception if you cross the boundaries (which you shouldn’t anyway). You can also access elements in a <code>std::vector</code> using pointer-like semantics by the use of iterators:</p>

<pre class="language-cpp line-numbers">
	<code>
		std::vector&lt;int&gt; integers{ 50, 1, 987, 1001 };
		std::vector&lt;int&gt;::const_iterator element = integers.cbegin();
		while (element != integers.end()) {
			size_t index = std::distance(integers.cbegin(), element);
			std::cout &lt;&lt; index &lt;&lt; " is: " &lt;&lt; *element &lt;&lt; std::endl;
			++element;
		}
	</code>
</pre>
