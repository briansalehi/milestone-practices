<p>An important part of the Standard Template Library (STL) is a set of generic functions, supplied by the header &lt;algorithm&gt;, that help  manipulate or work with the contents of a container.</p>

<p>Although most algorithms work via iterators on containers, not all algorithms necessarily work on containers and hence not all algorithms need iterators. Some, such as <code>swap()</code>, simply accept a pair of values to swap them. Similarly, <code>min()</code> and <code>max()</code> work directly on values, too.</p>

<p>Algorithms that change neither the order nor the contents of a container are called non-mutating algorithms. Some of the prominent non-mutating algorithms are shown in the following table:</p>

<table class="table table-dark">
	<thead>
		<tr>
			<th scope="col">Algorithm</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><i>Counting Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>count()</code></td>
			<td>Finds all elements in a range whose values match a supplied value</td>
		</tr>
		<tr>
			<td><code>count_if()</code></td>
			<td>Finds all elements in a range whose values satisfy a supplied condition</td>
		</tr>
		<tr>
			<td><i>Search Algorithm</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>search()</code></td>
			<td>Searches for the first occurrence of a given sequence within a target range either on the basis of element equality (that is, the <code>operator==</code> ) or using a specified binary predicate</td>
		</tr>
		<tr>
			<td><code>search_n()</code></td>
			<td>Searches a specified target range for the first occurrence of n number of elements of a given value or those that satisfy a given predicate</td>
		</tr>
		<tr>
			<td><code>find()</code></td>
			<td>Searches for the first element in the range that matches the specified value</td>
		</tr>
		<tr>
			<td><code>find_if()</code></td>
			<td>Searches for the first element in a range that satisfies the specified condition</td>
		</tr>
		<tr>
			<td><code>find_end()</code></td>
			<td>Searches for the last occurrence of a particular subrange in a supplied range</td>
		</tr>
		<tr>
			<td><code>find_first_of()</code></td>
			<td>Searches for the first occurrence of any element supplied in one range within a target range; or, in an overloaded version, searches for the first occurrence of an element that satisfies a supplied find criterion</td>
		</tr>
		<tr>
			<td><code>adjacent_find()</code></td>
			<td>Searches for two elements in a collection that are either equal or satisfy a supplied condition</td>
		</tr>
		<tr>
			<td><i>Comparison Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>equal()</code></td>
			<td>Compares two elements for equality or uses a specified binary predicate to determine the same</td>
		</tr>
		<tr>
			<td><code>mismatch()</code></td>
			<td>Locates the first difference position in two ranges of elements using a specified binary predicate</td>
		</tr>
		<tr>
			<td><code>lexicographical_compare()</code></td>
			<td>Compares the elements between two sequences to determine which is the lesser of the two</td>
		</tr>
	</tbody>
</table>

Mutating algorithms are those that change the contents or the order of the sequence they are operating on. Some of the most useful mutating algorithms supplied by STL are shown in the following table:

<table class="table table-dark">
	<thead>
		<tr>
			<th scope="col">Algorithm</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><i>Initialization Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>fill()</code></td>
			<td>Assigns the specified value to every element in the specified range.</td>
		</tr>
		<tr>
			<td><code>fill_n()</code></td>
			<td>Assigns the specified value to the first n elements in the specified range.</td>
		</tr>
		<tr>
			<td><code>generate()</code></td>
			<td>Assigns the return value of a specified function object to each element in the supplied range.</td>
		</tr>
		<tr>
			<td><code>generate_n()</code></td>
			<td>Assigns the value generated by a function to a specified count of values in a specified range.</td>
		</tr>
		<tr>
			<td><i>Modifying Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>for_each()</code></td>
			<td>Performs an operation on every element in a range. When the specified argument modifies the range, <code>std::for_each</code> becomes a mutating algorithm.</td>
		</tr>
		<tr>
			<td><code>transform()</code></td>
			<td>Applies a specified unary function on every element in the specified range.</td>
		</tr>
		<tr>
			<td><i>Copy Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>copy()</code></td>
			<td>Copies one range into another.</td>
		</tr>
		<tr>
			<td><code>copy_backward()</code></td>
			<td>Copies one range into another, arranging elements in the destination range in the reverse order.</td>
		</tr>
		<tr>
			<td><i>Removal Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>remove()</code></td>
			<td>Removes an element of a specified value from a specified range.</td>
		</tr>
		<tr>
			<td><code>remove_if()</code></td>
			<td>Removes an element that satisfies a specified unary predicate from a specified range.</td>
		</tr>
		<tr>
			<td><code>remove_copy()</code></td>
			<td>Copies all elements from a source range to a destination range, except those of a specified value.</td>
		</tr>
		<tr>
			<td><code>remove_copy_if()</code></td>
			<td>Copies all elements from a source range to a destination range except those that satisfy a specified unary predicate.</td>
		</tr>
		<tr>
			<td><code>unique()</code></td>
			<td>Compares adjacent elements in a range and removes the following duplicates. An overloaded version works using a binary predicate.</td>
		</tr>
		<tr>
			<td><code>unique_copy()</code></td>
			<td>Copies all but adjacent duplicate elements from a specified source range to a specified destination range.</td>
		</tr>
		<tr>
			<td><i>Replacement Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>replace()</code></td>
			<td>Replaces every element in a specified range that matches a specified value by a replacement value.</td>
		</tr>
		<tr>
			<td><code>replace_if()</code></td>
			<td>Replaces every element in a specified range that matches a specified value by a replacement value.</td>
		</tr>
		<tr>
			<td><i>Sort Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>sort()</code></td>
			<td>Sorts elements in a range using a specified sort criterion, which is a binary predicate that supplies a strict-weakâ€“ ordering. <code>sort</code> might change relative positions of equivalent elements.</td>
		</tr>
		<tr>
			<td><code>stable_sort()</code></td>
			<td>Stable sort is similar to sort but preserves order, too.</td>
		</tr>
		<tr>
			<td><code>partial_sort()</code></td>
			<td>Sorts a specified number of elements in a range.</td>
		</tr>
		<tr>
			<td><code>partial_sort_copy()</code></td>
			<td>Copies elements from a specified source range to a destination range that holds them in a sort order.</td>
		</tr>
		<tr>
			<td><i>Partitioning Algorithms</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>partition()</code></td>
			<td>Given a specified range, splits elements into two sets within it: those that satisfy a unary predicate come first and the rest after. Might not maintain the relative order of elements in a set.</td>
		</tr>
		<tr>
			<td><code>stable_partition()</code></td>
			<td>Partitions an input range into two sets as in partition but maintains relative ordering.</td>
		</tr>
		<tr>
			<td><i>Algorithms That Work on Sorted Containers</i></td>
			<td></td>
		</tr>
		<tr>
			<td><code>binary_search()</code></td>
			<td>Used to determine whether an element exists in a sorted collection.</td>
		</tr>
		<tr>
			<td><code>lower_bound()</code></td>
			<td>Returns an iterator pointing to the first position where an ele- ment can potentially be inserted in a sorted collection based on its value or on a supplied binary predicate.</td>
		</tr>
		<tr>
			<td><code>upper_bound()</code></td>
			<td>Returns an iterator pointing to the last position where an element can potentially be inserted into a sorted collection based on its value or on a supplied binary predicate.</td>
		</tr>
	</tbody>
</table>
