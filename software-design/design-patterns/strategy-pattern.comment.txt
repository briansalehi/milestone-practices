<b>Note:</b> Images appearing in this page is subject to copy right and will
be replaced by <a href="https://milextone.ir">Milestone</a> properties, DO NOT
USE THEM ELSEWHERE.

You may occasionally come across a design where part of your code needs
different behavior and you know that you just can't create an interface and
implement some classes with it each with different configurations.

Consider a duck simulation game having a <i>Duck</i> super class with
predefined behaviors: <i>quack, swim, display</i>.

![duck-simulation.png]

Now you want to add a <i>fly</i> behavior for ducks.

![duck-simulation-with-new-fly-behavior.png]

This change is usually inevitable in applications.
No matter how well you design an application, over time it must grow and
change or it will die.

Whenever you need to modify a behavior, you’re often forced to track down and
change it in all the different subclasses where that behavior is defined,
probably introducing new bugs along the way!

![duck-simulation-with-more-bugs.png]

For example we know that <i>fly()</i> and <i>quack()</i> are the parts of
the Duck class that vary across ducks.
You may think that to separate these behaviors from the <i>Duck</i> class,
we’ll pull both methods out of the <i>Duck</i> class and create a new set of
classes to represent each behavior.

![duck-simulation-with-behaviors-as-separate-classes.png]

But still you're going to need change a lot whenever new requirements arrive.
Luckily, there’s a design principle for just this situation.

The <b>Strategy Pattern</b> defines a family of algorithms, encapsulates each
one, and makes them interchangeable.

Identify the aspects of your application that vary and separate them from what
stays the same.

In other words, if you’ve got some aspect of your code that is changing, say
with every new requirement, then you know you’ve got a behavior that needs to
be pulled out and separated from all the stuff that doesn’t change.

Here’s another way to think about this principle: take the parts that vary and
encapsulate them, so that later you can alter or extend the parts that vary
without affecting those that don’t.
All patterns provide a way to let some part of a system vary independently of
all other parts.

As simple as this concept is, it forms the basis for almost every design
pattern. All patterns provide a way to let some part of a system vary
independently of all other parts.

We’ll use an interface to represent each behavior—for instance,
<i>FlyBehavior</i> and <i>QuackBehavior</i>—and each implementation of a
behavior will implement one of those interfaces.

![duck-simulation-with-separate-interfaces.png]

Notice that all ducks can swim, even Rubber Ducks and Decoy Ducks!
So, we are not going to separate them from implementation.

The <b>HAS-A</b> relationship is an interesting one: each duck has a
<i>FlyBehavior</i> and a <i>QuackBehavior</i> to which it delegates flying and
quacking.

![duck-simulation-with-behaviors-as-compositions.png]

When you put two classes together like this you’re using composition.
Instead of inheriting their behavior, the ducks get their behavior by being
composed with the right behavior object.

Creating systems using composition gives you a lot more flexibility. Not only
does it let you encapsulate a family of algorithms into their own set of
classes, but it also lets you change behavior at runtime as long as the object
you’re composing with implements the correct behavior interface.

<h4>Design Principle</h4>
Design to an interface, not an implementation.

![duck-simulation-quack-interface.png]

![duck-simulation-mallardduck-implementaion.png]

![duck-simulation-duck-implementation.png]

![duck-simulation-fly-implementation.png]

![duck-simulation-quack-implementation.png]

![duck-simulation-implementation.png]

![duck-simulation-with-runtime-behavior.png]

![duck-simulation-modelduck-with-dynamic-behavior.png]

![duck-simulation-execution.png]

![duck-simulation-diagram.png]
