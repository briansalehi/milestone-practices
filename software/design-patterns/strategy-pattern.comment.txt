<b>The Strategy Pattern defines a family of algorithms, encapsulates each
one, and makes them interchangeable.</b>

Identify the aspects of your application that vary and separate them from what
stays the same.

In other words, if you’ve got some aspect of your code that is changing, say
with every new requirement, then you know you’ve got a behavior that needs to
be pulled out and separated from all the stuff that doesn’t change.
Here’s another way to think about this principle: take the parts that vary and
encapsulate them, so that later you can alter or extend the parts that vary
without affecting those that don’t.
All patterns provide a way to let some part of a system vary independently of
all other parts.

When you put two classes together like this you’re using composition.
Instead of inheriting from behavior methods directly, they get their behavior
by being composed with the right behavior object.

<b>Design Principle</b>
Design to an interface, not an implementation.

Design Patterns give you a shared vocabulary with other developers.
Once you’ve got the vocabulary, you can more easily communicate with
other developers and inspire those who don’t know patterns to start
learning them. It also elevates your thinking about architectures by
letting you think at the pattern level, not the nitty-gritty object level.

The power of a shared pattern vocabulary When you communicate using
patterns, you are doing more than just sharing LINGO.
Shared pattern vocabularies are POWERFUL. When you communicate with another
developer or your team using patterns, you are communicating not just a
pattern name but a whole set of qualities, characteristics, and constraints
that the pattern represents.

Talking at the pattern level allows you to stay “in the design” longer.
Talking about software systems using patterns allows you to keep the
discussion at the design level, without having to dive down to the
nitty-gritty details of implementing objects and classes.
