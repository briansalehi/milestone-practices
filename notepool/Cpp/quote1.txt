Modern C++ Programming Cookbook, 2nd Edition (2020)
Marius Bancila

2 Working with Numbers and Strings



Converting between numeric and string types



Converting between number and string types is a ubiquitous operation.



With C++11, the standard library provides utility functions for converting between numbers and strings.



All the utility functions mentioned in this recipe are available in the <string> header.



To convert from an integer or fl oating-point type to a string type, use std::to_string() or std::to_wstring()



auto si = std::to_string(42); // si="42" auto sl = std::to_string(42L); // sl="42" auto su = std::to_string(42u); // su="42" auto sd = std::to_wstring(42.0); // sd=L"42.000000" auto sld = std::to_wstring(42.0L); // sld=L"42.000000"



To convert from a string type to an integer type, use std::stoi(), std::stol(), std::stoll(), std::stoul(), or std::stoull()



auto i1 = std::stoi("42"); // i1 = 42 auto i2 = std::stoi("101010", nullptr, 2); // i2 = 42 auto i3 = std::stoi("052", nullptr, 8); // i3 = 42 auto i4 = std::stoi("0x2A", nullptr, 16); // i4 = 42



To convert from a string type to a fl oating-point type, use std::stof(), std::stod(), or std::stold()



// d1 = 123.45000000000000 auto d1 = std::stod("123.45");
// d2 = 123.45000000000000 auto d2 = std::stod("1.2345e+2");
// d3 = 123.44999980926514 auto d3 = std::stod("0xF.6E6666p3");



When it comes to the opposite conversion, there is an entire set of functions that have a name with the format ston (string to number), where n stands for i (integer), l (long), ll (long long), ul (unsigned long), or ull (unsigned long long). 
The following list shows all these functions, each of them with two overloads—one that takes an std::string and one that takes an std::wstring as the fi rst parameter:



int stoi(const std::string& str, std::size_t* pos = 0,  int base = 10);
int stoi(const std::wstring& str, std::size_t* pos = 0,  int base = 10);
long stol(const std::string& str, std::size_t* pos = 0,  int base = 10);
long stol(const std::wstring& str, std::size_t* pos = 0,  int base = 10);
long long stoll(const std::string& str, std::size_t* pos = 0,  int base = 10);
long long stoll(const std::wstring& str, std::size_t* pos = 0,  int base = 10);
unsigned long stoul(const std::string& str, std::size_t* pos = 0,  int base = 10);
unsigned long stoul(const std::wstring& str, std::size_t* pos = 0,  int base = 10);
unsigned long long stoull(const std::string& str,  std::size_t* pos = 0, int base = 10);
unsigned long long stoull(const std::wstring& str,  std::size_t* pos = 0, int base = 10);
float stof(const std::string& str, std::size_t* pos = 0);
float stof(const std::wstring& str, std::size_t* pos = 0);
double stod(const std::string& str, std::size_t* pos = 0);
double stod(const std::wstring& str, std::size_t* pos = 0);
long double stold(const std::string& str, std::size_t* pos = 0);
long double stold(const std::wstring& str, std::size_t* pos = 0);



The way the string to integral type functions work is by discarding all white spaces before a non-whitespace character, then taking as many characters as possible to form a signed or unsigned number (depending on the case), and then converting that to the requested integral type (stoi() will return an integer, stoul() will return an unsigned long, and so on). In all the following examples, the result is the integer 42, except for the last example, where the result is -42:



auto i1 = std::stoi("42"); // i1 = 42 auto i2 = std::stoi(" 42"); // i2 = 42 auto i3 = std::stoi(" 42fortytwo"); // i3 = 42 auto i4 = std::stoi("+42"); // i4 = 42 auto i5 = std::stoi("-42"); // i5 = -42



A valid integral number may consist of the following parts:



• A sign, plus (+) or minus (-) (optional)



• Pref i x 0 to indicate an octal base (optional)



• Pref i x 0x or 0X to indicate a hexadecimal base (optional)



• A sequence of digits



The functions that convert a string to an integer have three parameters:



• The input string.



• A pointer that, when not null, will receive the number of characters that were processed. This can include any leading whitespaces that were discarded, the sign, and the base pref i x, so it should not be confused with the number of digits the integral value has.



• A number indicating the base; by default, this is 10.



An important thing to note is that these conversion functions throw an exception if the conversion fails. There are two exceptions that can be thrown:



std::invalid_argument: If the conversion cannot be performed:



try {  auto i16 = std::stoi("");
} catch (std::exception const & e) {  // prints "invalid stoi argument"  std::cout << e.what() << '\n';
}



std::out_of_range: If the converted value is outside the range of the result type (or if the underlying function sets errno to ERANGE):



try {  // OK  auto i17 = std::stoll("12345678901234");
 // throws std::out_of_range  auto i18 = std::stoi("12345678901234");
} catch (std::exception const & e) {  // prints "stoi argument out of range"  std::cout << e.what() << '\n';
}



A valid fl oating-point value can have different representations in the input string:



• Decimal fl oating-point expression (optional sign, sequence of decimal digits with optional point, optional e or E, followed by exponent with optional sign).



• Binary fl oating-point expression (optional sign, 0x or 0X pref i x, sequence of hexadecimal digits with optional point, optional p or P, followed by exponent with optional sign).



• Inf i nity expression (optional sign followed by case-insensitive INF or INFINITY).



• A non-number expression (optional sign followed by case-insensitive NAN and possibly other alphanumeric characters).



The following are various examples of converting strings to doubles:



auto d1 = std::stod("123.45"); // d1 = 123.45000000000000 auto d2 = std::stod("+123.45"); // d2 = 123.45000000000000 auto d3 = std::stod("-123.45"); // d3 = -123.45000000000000 auto d4 = std::stod(" 123.45"); // d4 = 123.45000000000000 auto d5 = std::stod(" -123.45abc"); // d5 = -123.45000000000000 auto d6 = std::stod("1.2345e+2"); // d6 = 123.45000000000000 auto d7 = std::stod("0xF.6E6666p3"); // d7 = 123.44999980926514 auto d8 = std::stod("INF"); // d8 = inf auto d9 = std::stod("-infinity"); // d9 = -inf auto d10 = std::stod("NAN"); // d10 = nan auto d11 = std::stod("-nanabc"); // d11 = -nan



A fl oating-point constant in the base 2 scientif i c notation is composed of several parts:



• The hexadecimal pref i x 0x.



• An integer part, which in this example was F, which in decimal is 15.



• A fractional part, which in this example was 6E6666, or 011011100110011001100110 in binary. To convert that into decimal, we need to add inverse powers of two: 1/4 + 1/8 + 1/32 + 1/64 + 1/128 + ....



• A suff i x, representing a power of 2; in this example, p3 means 2 at the power of 3.



Limits and other properties of numeric types



Sometimes, it is necessary to know and use the minimum and maximum values that can be represented with a numeric type, such as char, int, or double. Many developers use standard C macros for this, such as CHAR_MIN/CHAR_MAX, INT_MIN/ INT_MAX, and DBL_MIN/DBL_MAX. C++ provides a class template called numeric_limits with specializations for every numeric type that enables you to query the minimum and maximum value of a type. However, numeric_limits is not limited to that functionality, and offers additional constants for type property querying, such as whether a type is signed or not, how many bits it needs for representing its values, whether it can represent inf i nity for fl oating-point types, and many others. Prior to C++11, the use of numeric_limits<T> was limited because it could not be used in places where constants were needed (examples include the size of arrays and switch cases). Due to that, developers preferred to use C macros throughout their code. In C++11, that is no longer the case, as all the static members of numeric_limits<T> are now constexpr, which means they can be used everywhere a constant expression is expected.



The numeric_limits<T> class template is available in the namespace std in the <limits> header.



Use the min() and max() static methods to get the smallest and largest fi nite numbers of a type. The following are examples of how these could be used:



template<typename T, typename Iter> T minimum(Iter const start, Iter const end) // finds the  // minimum value  // in a range {  T minval = std::numeric_limits<T>::max();
 for (auto i = start; i < end; ++i)  {  if (*i < minval)  minval = *i;
 }  return minval;
}



int range[std::numeric_limits<char>::max() + 1] = { 0 };



switch(get_value()) {  case std::numeric_limits<int>::min():
 // do something  break;
}



Use other static methods and static constants to retrieve other properties of a numeric type. In the following example, the variable bits is an std::bitset object that contains a sequence of bits that are necessary to represent the numerical value represented by the variable n (which is an integer):



auto n = 42;
std::bitset<std::numeric_limits<decltype(n)>::digits>  bits { static_cast<unsigned long long>(n) };



In C++11, there is no limitation to where std::numeric_ limits<T> can be used; therefore, preferably, use it over C macros in your modern C++ code.



The following specializations of numeric types are available in the <limits> header. 
Note that specializations for char16_t and char32_t are new in C++11; the others were available previously. Apart from the specializations listed ahead, the library also includes specializations for every cv-qualified version of these numeric types, and they are identical to the unqualif i ed specialization. For example, consider the type int; there are four actual specializations (and they are identical): numeric_ limits<int>, numeric_limits<const int>, numeric_limits<volatile int>, and numeric_limits<const volatile int>:



template<> class numeric_limits<bool>;
template<> class numeric_limits<char>;
template<> class numeric_limits<signed char>;
template<> class numeric_limits<unsigned char>;
template<> class numeric_limits<wchar_t>;
template<> class numeric_limits<char16_t>;
template<> class numeric_limits<char32_t>;
template<> class numeric_limits<short>;
template<> class numeric_limits<unsigned short>;
template<> class numeric_limits<int>;
template<> class numeric_limits<unsigned int>;
template<> class numeric_limits<long>;
template<> class numeric_limits<unsigned long>;
template<> class numeric_limits<long long>;
template<> class numeric_limits<unsigned long long>;
template<> class numeric_limits<float>;
template<> class numeric_limits<double>;
template<> class numeric_limits<long double>;



The following function template, print_type_properties(), prints the minimum and maximum fi nite values of the type, as well as other information:



template <typename T> void print_type_properties() {  std::cout  << "min="  << std::numeric_limits<T>::min() << '\n'  << "max="  << std::numeric_limits<T>::max() << '\n'  << "bits="  << std::numeric_limits<T>::digits << '\n'  << "decdigits="  << std::numeric_limits<T>::digits10 << '\n'  << "integral="  << std::numeric_limits<T>::is_integer << '\n'  << "signed="  << std::numeric_limits<T>::is_signed << '\n'  << "exact="  << std::numeric_limits<T>::is_exact << '\n'  << "infinity="  << std::numeric_limits<T>::has_infinity << '\n';
}



If we call the print_type_properties() function for unsigned short, int, and double, we will get the following output:



unsigned short



int



double



min=0 max=65535 bits=16 decdigits=4 integral=1 signed=0 exact=1 infinity=0



min=-2147483648 max=2147483647 bits=31 decdigits=9 integral=1 signed=1 exact=1 infinity=0



min=2.22507e-308 max=1.79769e+308 bits=53 decdigits=15 integral=0 signed=1 exact=0 infinity=1



digits represents the number of bits (excluding the sign bit if present) and padding bits (if any) for integral types and the number of bits of the mantissa for fl oating-point types.



digits10 is the number of decimal digits that can be represented by a type without a change. To understand this better, let's consider the case of unsigned short. This is a 16-bit integral type. It can represent numbers between 0 and 65,536. It can represent numbers up to fi ve decimal digits, 10,000 to 65,536, but it cannot represent all fi ve decimal digit numbers, as numbers from 65,537 to 99,999 require more bits. Therefore, the largest numbers that it can represent without requiring more bits have four decimal digits (numbers from 1,000 to 9,999). This is the value indicated by digits10. 
For integral types, it has a direct relationship to constant digits; for an integral type, T, the value of digits10 is std::numeric_limits<T>::digits * std::log10(2).



It's worth mentioning that the standard library types that are aliases of arithmetic types (such as std::size_t) may also be inspected with std::numeric_limits. 
On the other hand, other standard types that are not arithmetic types, such as std::complex<T> or std::nullptr_t, do not have std::numeric_limits specializations.



Generating pseudo-random numbers



Modern C++ provides support for generating pseudo-random numbers through a pseudo-random number library containing number generators and distributions. 
Theoretically, it can also produce true random numbers, but in practice, those could actually be only pseudo-random.



Understanding the difference between random and pseudo-random numbers is key. True random numbers are numbers that cannot be predicted better than by random chance, and are produced with the help of hardware random number generators. Pseudo-random numbers are numbers produced with the help of algorithms that generate sequences with properties that approximate the ones of true random numbers.



Furthermore, being familiar with various statistical distributions is a plus. It is mandatory, though, that you know what a uniform distribution is, because all engines in the library produce numbers that are uniformly distributed. Without going into any details, we will just mention that uniform distribution is a probability distribution that is concerned with events that are equally likely to occur (within certain bounds).



To generate pseudo-random numbers in your application, you should perform the following steps:



1. Include the header <random>:



#include <random>



2. Use an std::random_device generator for seeding a pseudo-random engine:



std::random_device rd{};



3. Use one of the available engines for generating numbers and initialize it with a random seed:



auto mtgen = std::mt19937{ rd() };



4. Use one of the available distributions for converting the output of the engine to one of the desired statistical distributions:



auto ud = std::uniform_int_distribution<>{ 1, 6 };



5. Generate the pseudo-random numbers:



for(auto i = 0; i < 20; ++i)  auto number = ud(mtgen);



The pseudo-random number library contains two types of components:



• Engines, which are generators of random numbers; these can produce either pseudo-random numbers with a uniform distribution or, if available, actual random numbers.



• Distributions that convert the output of an engine to a statistical distribution.



All engines (except for random_device) produce integer numbers in a uniform distribution, and all engines implement the following methods:



• min(): This is a static method that returns the minimum value that can be produced by the generator.



• max(): This is a static method that returns the maximum value that can be produced by the generator.



• seed(): This initializes the algorithm with a start value (except for random_ device, which cannot be seeded).



• operator(): This generates a new number uniformly distributed between min() and max().



• discard(): This generates and discards a given number of pseudo-random numbers.



The following engines are available:



• linear_congruential_engine: This is a linear congruential generator that produces numbers using the following formula:



x(i) = (A * x(i – 1) + C) mod M
--
screenshots after this



However, this is not a reliable method for determining whether the device is actually deterministic or non-deterministic.



All these generators produce integers in a uniform distribution. This is, however, only one of the many possible statistical distributions where random numbers are needed in most applications. To be able to produce numbers (either integer or real) in other distributions, the library provides several classes called distributions. 
These convert the output of an engine according to the statistical distribution it implements. The following distributions are available:
--
distribution tables after this



Each of the engines provided by the library has advantages and disadvantages, as it was mentioned earlier. The Mersenne twister, although the slowest and one that has the largest internal state, when initialized appropriately, can produce the longest non-repeating sequence of numbers. In the following examples, we will use std::mt19937, a 32-bit Mersenne twister with 19,937 bits of internal state.



The simplest way to generate random numbers looks like this:



auto mtgen = std::mt19937 {};
for (auto i = 0; i < 10; ++i)  std::cout << mtgen() << '\n';



In this example, mtgen is std::mt19937 for the Mersenne twister. To generate numbers, you only need to use the call operator that advances the internal state and returns the next pseudo-random number. However, this code is fl awed, as the engine is not seeded. As a result, it always produces the same sequence of numbers, which is probably not what you want in most cases.



There are different approaches for initializing the engine. One approach, common with the C random library, is to use the current time. In modern C++, it should look like this:



auto seed = std::chrono::high_resolution_clock::now()  .time_since_epoch()  .count();
auto mtgen = std::mt19937{ static_cast<unsigned int>(seed) };



In this example, seed is a number representing the number of ticks since the clock's epoch until the present moment. This number is then used to seed the engine. The problem with this approach is that the value of that seed is actually deterministic, and in some classes of applications, it could be prone to attacks. A more reliable approach is to seed the generator with actual random numbers.



The std::random_device class is an engine that is supposed to return true random numbers, though implementations could actually be based on a pseudo-random generator:



std::random_device rd;
auto mtgen = std::mt19937 {rd()};



Numbers produced by all engines follow a uniform distribution. To convert the result to another statistical distribution, we have to use a distribution class. To show how generated numbers are distributed according to the selected distribution, we will use the following function. This function generates a specif i ed number of pseudo-random numbers and counts their repetition in a map. The values from the map are then used to produce a bar-like diagram showing how often each number occurred:



void generate_and_print(std::function<int(void)> gen,  int const iterations = 10000) {  // map to store the numbers and their repetition  auto data = std::map<int, int>{};
 // generate random numbers  for (auto n = 0; n < iterations; ++n)  ++data[gen()];
 // find the element with the most repetitions  auto max = std::max_element(  std::begin(data), std::end(data),  [](auto kvp1, auto kvp2) {  return kvp1.second < kvp2.second; });
 // print the bars  for (auto i = max->second / 200; i > 0; --i)  {  for (auto kvp : data)  {  std::cout  << std::fixed << std::setprecision(1) << std::setw(3)  << (kvp.second / 200 >= i ? (char)219 : ' ');
 }  std::cout << '\n';
 }



// print the numbers  for (auto kvp : data)  {  std::cout  << std::fixed << std::setprecision(1) << std::setw(3)  << kvp.first;
 }  std::cout << '\n';
}



The following code generates random numbers using the std::mt19937 engine with a uniform distribution in the range [1, 6]; this is basically what you get when you throw a dice:



std::random_device rd{};
auto mtgen = std::mt19937{ rd() };
auto ud = std::uniform_int_distribution<>{ 1, 6 };
generate_and_print([&mtgen, &ud]() {return ud(mtgen); });



The output of the program looks like this:



Figure 2.1: Uniform distribution of the range [1,6]



In the next and fi nal example, we're changing the distribution to a normal distribution with a mean of 5 and a standard deviation of 2. This distribution produces real numbers; therefore, in order to use the previous generate_and_print() function, the numbers must be rounded to integers:



std::random_device rd{};
auto mtgen = std::mt19937{ rd() };



auto nd = std::normal_distribution<>{ 5, 2 };
generate_and_print(  [&mtgen, &nd]() {  return static_cast<int>(std::round(nd(mtgen))); });



The following will be the output of the preceding code:



Here, we can see that, based on the graphical representation, the distribution has changed from a uniform one to a normal one with the mean at value 5.



Initializing all bits of internal state of a pseudo-random number generator



One important factor that was overlooked in that recipe is the proper initialization of the pseudo-random number generators.



With careful analysis (that is beyond the purpose of this recipe or this book), it can be shown that the Mersenne twister engine has a bias toward producing some values repeatedly and omitting others, thus generating numbers not in a uniform distribution, but rather in a binomial or Poisson distribution. In this recipe, you will learn how to initialize a generator in order to produce pseudo-random numbers with a true uniform distribution.



How to do it...



To properly initialize a pseudo-random number generator to produce a uniformly distributed sequence of pseudo-random numbers, perform the following steps:



1. Use an std::random_device to produce random numbers to be used as seeding values:



std::random_device rd;



2. Generate random data for all internal bits of the engine:



std::array<int, std::mt19937::state_size> seed_data {};
std::generate(std::begin(seed_data), std::end(seed_data),  std::ref(rd));



3. Create an std::seed_seq object from the previously generated pseudo-random data:



std::seed_seq seq(std::begin(seed_data), std::end(seed_data));



4. Create an engine object and initialize all the bits representing the internal state of the engine; for example, an mt19937 has 19,937 bits of internal states:



auto eng = std::mt19937{ seq };



5. Use the appropriate distribution based on the requirements of the application:



auto dist = std::uniform_real_distribution<>{ 0, 1 };



How it works...



In all the examples shown in the previous recipe, we used the std::mt19937 engine to produce pseudo-random numbers. Though the Mersenne twister is slower than the other engines, it can produce the longest sequences of non-repeating numbers with the best spectral characteristics. However, initializing the engine in the manner shown in the previous recipe will not have this effect. The problem is that the internal state of mt19937 has 624 32-bit integers, and in the examples from the previous recipe, we have only initialized one of them.



When working with the pseudo-random number library, remember the following rule of thumb



In order to produce the best results, engines must have all their internal state properly initialized before generating numbers.



The pseudo-random number library provides a class for this particular purpose, called std::seed_seq. This is a generator that can be seeded with any number of 32-bit integers and produces the requested number of integers evenly distributed in the 32-bit space.



In the preceding code from the How to do it... section, we def i ned an array called seed_data with a number of 32-bit integers equal to the internal state of the mt19937 generator; that is, 624 integers. Then, we initialized the array with random numbers produced by std::random_device. The array was later used to seed std::seed_seq, which, in turn, was used to seed the mt19937 generator.



Creating cooked user-def i ned literals



Literals are constants of built-in types (numerical, Boolean, character, character string, and pointer) that cannot be altered in a program. The language def i nes a series of pref i xes and suff i xes to specify literals (and the pref i x/suff i x is actually part of the literal). C++11 allows us to create user-def i ned literals by def i ning functions called literal operators, which introduce suff i xes for specifying literals. These work only with numerical character and character string types.



This opens the possibility of def i ning both standard literals in future versions and allows developers to create their own literals.



User-def i ned literals can have two forms: raw and cooked. Raw literals are not processed by the compiler, whereas cooked literals are values processed by the compiler



Raw literals are only available for integral and fl oating-point types, whereas cooked literals are also available for character and character string literals.



How to do it...



To create cooked user-def i ned literals, you should follow these steps:



1. Def i ne your literals in a separate namespace to avoid name clashes.



2. Always pref i x the user-def i ned suff i x with an underscore (_).



3. Def i ne a literal operator of one of the following forms for cooked literals:



T operator "" _suffix(unsigned long long int);
T operator "" _suffix(long double);
T operator "" _suffix(char);
T operator "" _suffix(wchar_t);
T operator "" _suffix(char16_t);
T operator "" _suffix(char32_t);
T operator "" _suffix(char const *, std::size_t);
T operator "" _suffix(wchar_t const *, std::size_t);
T operator "" _suffix(char16_t const *, std::size_t);
T operator "" _suffix(char32_t const *, std::size_t);



The following example creates a user-def i ned literal for specifying kilobytes:



namespace compunits {  constexpr size_t operator "" _KB(unsigned long long const size)  {  return static_cast<size_t>(size * 1024);
 } }



auto size{ 4_KB }; // size_t size = 4096;
using byte = unsigned char;
auto buffer = std::array<byte, 1_KB>{};



How it works...



In the example shown in the How to do it... section, the literal operator is called operator "" _KB and has an argument of type unsigned long long int. This is the only integral type possible for literal operators for handling integral types. Similarly, for fl oating-point user-def i ned literals, the parameter type must be long double since for numeric types, the literal operators must be able to handle the largest possible values. This literal operator returns a constexpr value so that it can be used where compile-time values are expected, such as specifying the size of an array, as shown in the preceding example.



When the compiler identif i es a user-def i ned literal and has to call the appropriate user-def i ned literal operator, it will pick the overload from the overload set according to the following rules:



• For integral literals: It calls in the following order: the operator that takes an unsigned long long, the raw literal operator that takes a const char*, or the literal operator template.



• For fl oating-point literals: It calls in the following order: the operator that takes a long double, the raw literal operator that takes a const char*, or the literal operator template.



• For character literals: It calls the appropriate operator, depending on the character type (char, wchar_t, char16_t, and char32_t).



• For string literals: It calls the appropriate operator, depending on the string type, that takes a pointer to the string of characters and the size.



Though user-def i ned literals are available from C++11, standard literal operators have been available only from C++14. Further standard user-def i ned literals have been added to the next versions of the standard. The following is a list of these standard literal operators:



operator""s for def i ning std::basic_string literals and operator""sv (in C++17) for def i ning std::basic_string_view literals:



using namespace std::string_literals;
auto s1{ "text"s }; // std::string auto s2{ L"text"s }; // std::wstring auto s3{ u"text"s }; // std::u16string auto s4{ U"text"s }; // std::u32string using namespace std::string_view_literals;
auto s5{ "text"sv }; // std::string_view



operator""h, operator""min, operator""s, operator""ms, operator""us, and operator""ns for creating an std::chrono::duration value:



using namespace std::chrono_literals;
// std::chrono::duration<long long> auto timer {2h + 42min + 15s};



operator""y for creating an std::chrono::year literal and operator""d for creating an std::chrono::day literal that represents a day of a month, both added to C++20:



using namespace std::chrono_literals;
auto year { 2020y }; // std::chrono::year auto day { 15d }; // std::chrono::day



operator""if, operator""i, and operator""il for creating an std::complex value:



using namespace std::complex_literals;
auto c{ 12.0 + 4.5i }; // std::complex<double>



The standard user-def i ned literals are available in multiple namespaces. For instance, the ""s and ""sv literals for strings are def i ned in the namespace std::literals::string_literals.



However, both literals and string_literals are inlined namespaces. Therefore, you can access the literals with using namespace std::literals, using namespace std::string_literals, or using namespace std::literals::string_literals. In the previous examples, the second form was preferred.



Creating raw user-def i ned literals



Raw literals are useful for altering the compiler's normal behavior. For instance, a sequence such as 3.1415926 is interpreted by the compiler as a fl oating-point value, but with the use of a raw user-def i ned literal, it could be interpreted as a user-def i ned decimal value.



To exemplify the way raw user-def i ned literals can be created, we will def i ne binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned) types. These types will be called byte8, byte16, and byte32, and the literals we will create will be called _b8, _b16, and _b32.



To create raw user-def i ned literals, you should follow these steps:



1. Def i ne your literals in a separate namespace to avoid name clashes.



2. Always pref i x the used-def i ned suff i x with an underscore (_).



3. Def i ne a literal operator or literal operator template of the following form:



T operator "" _suffix(const char*);
template<char...> T operator "" _suffix();



The following example shows a possible implementation of 8-bit, 16-bit, and 32-bit binary literals:



namespace binary {  using byte8 = unsigned char;
 using byte16 = unsigned short;
 using byte32 = unsigned int;
 namespace binary_literals  {  namespace binary_literals_internals  {  template <typename CharT, char... bits>  struct binary_struct;
 template <typename CharT, char... bits>  struct binary_struct<CharT, '0', bits...>  {  static constexpr CharT value{  binary_struct<CharT, bits...>::value };
 };
 template <typename CharT, char... bits>  struct binary_struct<CharT, '1', bits...>  {  static constexpr CharT value{  static_cast<CharT>(1 << sizeof...(bits)) |  binary_struct<CharT, bits...>::value };
 };



template <typename CharT>  struct binary_struct<CharT>  {  static constexpr CharT value{ 0 };
 };
 }  template<char... bits>  constexpr byte8 operator""_b8()  {  static_assert(  sizeof...(bits) <= 8,  "binary literal b8 must be up to 8 digits long");
 return binary_literals_internals::
 binary_struct<byte8, bits...>::value;
 }  template<char... bits>  constexpr byte16 operator""_b16()  {  static_assert(  sizeof...(bits) <= 16,  "binary literal b16 must be up to 16 digits long");
 return binary_literals_internals::
 binary_struct<byte16, bits...>::value;
 }  template<char... bits>  constexpr byte32 operator""_b32()  {  static_assert(  sizeof...(bits) <= 32,  "binary literal b32 must be up to 32 digits long");
 return binary_literals_internals::
 binary_struct<byte32, bits...>::value;
 }  } }



First of all, we def i ne everything inside a namespace called binary and start with introducing several type aliases: byte8, byte16, and byte32. These represent integral types of 8 bits, 16 bits, and 32 bits, as the names imply.



The implementation in the previous section enables us to def i ne binary literals of the form 1010_b8 (a byte8 value of decimal 10) or 000010101100_b16 (a byte16 value of decimal 2130496). However, we want to make sure that we do not exceed the number of digits for each type. In other words, values such as 111100001_b8 should be illegal and the compiler should yield an error.



The literal operator templates are def i ned in a nested namespace called binary_ literal_internals. This is a good practice in order to avoid name collisions with other literal operators from other namespaces. Should something like that happen, you can choose to use the appropriate namespace in the right scope (such as one namespace in a function or block and another namespace in another function or block).



bits is a template parameter pack that is not a single value, but all the values the template could be instantiated with. For example, if we consider the literal 1010_b8, then the literal operator template would be instantiated as operator"" _b8<'1', '0', '1', '0'>(). Before proceeding with computing the binary value, we check the number of digits in the literal. For _b8, this must not exceed eight (including any trailing zeros). Similarly, it should be up to 16 digits for _b16 and 32 for _b32. For this, we use the sizeof... operator, which returns the number of elements in a parameter pack (in this case, bits).



If the number of digits is correct, we can proceed to expand the parameter pack and recursively compute the decimal value represented by the binary literal. This is done with the help of an additional class template and its specializations. These templates are def i ned in yet another nested namespace, called binary_literals_internals. 
This is also a good practice because it hides (without proper qualif i cation) the implementation details from the client (unless an explicit using namespace directive makes them available to the current namespace).



Even though this looks like recursion, it is not a true runtime recursion. This is because after the compiler expands and generates the code from templates, what we end up with is basically calls to overloaded functions with a different number of parameters. This is explained later in the Writing a function template with a variable number of arguments



The binary_struct class template has a template type of CharT for the return type of the function (we need this because our literal operator templates should return either byte8, byte16, or byte32) and a parameter pack:



template <typename CharT, char... bits> struct binary_struct;



Several specializations of this class template are available with parameter pack decomposition. When the fi rst digit of the pack is '0', the computed value remains the same, and we continue expanding the rest of the pack. If the fi rst digit of the pack is '1', then the new value is 1, shifted to the left with the number of digits in the remainder of the pack bit, or the value of the rest of the pack:



template <typename CharT, char... bits> struct binary_struct<CharT, '0', bits...> {  static constexpr CharT value{  binary_struct<CharT, bits...>::value };
};
template <typename CharT, char... bits> struct binary_struct<CharT, '1', bits...> {  static constexpr CharT value{  static_cast<CharT>(1 << sizeof...(bits)) |  binary_struct<CharT, bits...>::value };
};



The last specialization covers the case where the pack is empty; in this case, we return 0:



template <typename CharT> struct binary_struct<CharT> {  static constexpr CharT value{ 0 };
};



After def i ning these helper classes, we could implement the byte8, byte16, and byte32 binary literals as intended. Note that we need to bring the content of the namespace binary_literals into the current namespace in order to use the literal operator templates:



using namespace binary;
using namespace binary_literals;
auto b1 = 1010_b8;
auto b2 = 101010101010_b16;
auto b3 = 101010101010101010101010_b32;



The following def i nitions trigger compiler errors:



// binary literal b8 must be up to 8 digits long auto b4 = 0011111111_b8;
// binary literal b16 must be up to 16 digits long auto b5 = 001111111111111111_b16;
// binary literal b32 must be up to 32 digits long auto b6 = 0011111111111111111111111111111111_b32;



The reason for this is that the condition in static_assert is not met. The length of the sequence of characters preceding the literal operator is greater than expected, in all cases.



Using raw string literals to avoid escaping characters



Strings may contain special characters, such as non-printable characters (newline, horizontal and vertical tab, and so on), string and character delimiters (double and single quotes), or arbitrary octal, hexadecimal, or Unicode values. These special characters are introduced with an escape sequence that starts with a backslash, followed by either the character (examples include ' and "), its designated letter (examples include n for a new line, t for a horizontal tab), or its value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As a result, the backslash character itself has to be escaped with another backslash character. This leads to more complicated literal strings that can be hard to read.



To avoid escaping characters, C++11 introduced raw string literals that do not process escape sequences.



To avoid escaping characters, def i ne the string literals with one of the following forms:



R"( literal )" as the default form:



auto filename {R"(C:\Users\Marius\Documents\)"s};



auto pattern {R"((\w+)=(\d+)$)"s};



auto sqlselect {  R"(SELECT *  FROM Books  WHERE Publisher='Packtpub'  ORDER BY PubDate DESC)"s};



R"delimiter( literal )delimiter", where delimiter is any sequence of characters excluding parentheses, backslash, and spaces, and literal is any sequence of characters with the limitation that it cannot include the closing sequence )delimiter". Here is an example with !! as delimiter:



auto text{ R"!!(This text contains both "( and )".)!!"s };
std::cout << text << '\n';



When string literals are used, escapes are not processed, and the actual content of the string is written between the delimiter (in other words, what you see is what you get). The following example shows what appears as the same raw literal string; 
however, the second one still contains escaped characters. Since these are not processed in the case of string literals, they will be printed as they are in the output:



auto filename1 {R"(C:\Users\Marius\Documents\)"s};
auto filename2 {R"(C:\\Users\\Marius\\Documents\\)"s};
// prints C:\Users\Marius\Documents\ std::cout << filename1 << '\n';
// prints C:\\Users\\Marius\\Documents\\ std::cout << filename2 << '\n';



If the text has to contain the )" sequence, then a different delimiter must be used, in the R"delimiter( literal )delimiter" form. According to the standard, the possible characters in a delimiter can be as follows:



"Any member of the basic source character set except: space, the left parenthesis (the right parenthesis ), the backslash \, and the control characters representing horizontal tab, vertical tab, form feed, and newline."
--
quote the text



Raw string literals can be pref i xed by one of L, u8, u, and U to indicate a wide, UTF-8, UTF-16, or UTF-32 string literal, respectively. The following are examples of such string literals:



auto t1{ LR"(text)" }; // const wchar_t* auto t2{ u8R"(text)" }; // const char* auto t3{ uR"(text)" }; // const char16_t* auto t4{ UR"(text)" }; // const char32_t* auto t5{ LR"(text)"s }; // wstring



auto t6{ u8R"(text)"s }; // string auto t7{ uR"(text)"s }; // u16string auto t8{ UR"(text)"s }; // u32string



Note that the presence of the suff i x ""s at the end of the string makes the compiler deduce the type as various string classes and not character arrays.



Creating a library of string helpers



The string types from the standard library are a general-purpose implementation that lacks many helpful methods, such as changing the case, trimming, splitting, and others that may address different developer needs. Third-party libraries that provide rich sets of string functionalities exist. However, in this recipe, we will look at implementing several simple, yet helpful, methods you may often need in practice. 
The purpose is rather to see how string methods and standard general algorithms can be used for manipulating strings, but also to have a reference to reusable code that can be used in your applications.



The string library we will be implementing should work with all the standard string types; that is, std::string, std::wstring, std::u16string, and std::u32string.



To avoid specifying long names such as std::basic_string<CharT, std::char_ traits<CharT>, std::allocator<CharT>>, we will use the following alias templates for strings and string streams:



template <typename CharT> using tstring =  std::basic_string<CharT, std::char_traits<CharT>,  std::allocator<CharT>>;
template <typename CharT> using tstringstream =  std::basic_stringstream<CharT, std::char_traits<CharT>,  std::allocator<CharT>>;



To implement these string helper functions, we need to include the header <string> for strings and <algorithm> for the general standard algorithms we will use.



In all the examples in this recipe, we will use the standard user-def i ned literal operators for strings from C++14, for which we need to explicitly use the std::string_literals namespace.



How to do it...



To convert a string to lowercase or uppercase, apply the tolower() or toupper() functions to the characters of a string using the general-purpose algorithm std::transform():



template<typename CharT> inline tstring<CharT> to_upper(tstring<CharT> text) {  std::transform(std::begin(text), std::end(text),  std::begin(text), toupper);
 return text;
} template<typename CharT> inline tstring<CharT> to_lower(tstring<CharT> text) {  std::transform(std::begin(text), std::end(text),  std::begin(text), tolower);
 return text;
}



To reverse a string, use the general-purpose algorithm std::reverse():



template<typename CharT> inline tstring<CharT> reverse(tstring<CharT> text) {  std::reverse(std::begin(text), std::end(text));
 return text;
}



To trim a string, at the beginning, end, or both, use the std::basic_string methods find_first_not_of() and find_last_not_of():



template<typename CharT> inline tstring<CharT> trim(tstring<CharT> const & text) {  auto first{ text.find_first_not_of(' ') };
 auto last{ text.find_last_not_of(' ') };
 return text.substr(first, (last - first + 1));
}



template<typename CharT> inline tstring<CharT> trimleft(tstring<CharT> const & text) {  auto first{ text.find_first_not_of(' ') };
 return text.substr(first, text.size() - first);
}



template<typename CharT> inline tstring<CharT> trimright(tstring<CharT> const & text) {  auto last{ text.find_last_not_of(' ') };
 return text.substr(0, last + 1);
}



To trim characters in a given set from a string, use overloads of the std::basic_string methods find_first_not_of() and find_last_not_of(), which take a string parameter that def i nes the set of characters to look for:



template<typename CharT> inline tstring<CharT> trim(tstring<CharT> const & text,  tstring<CharT> const & chars) {  auto first{ text.find_first_not_of(chars) };
 auto last{ text.find_last_not_of(chars) };



return text.substr(first, (last - first + 1));
}



template<typename CharT> inline tstring<CharT> trimleft(tstring<CharT> const & text,  tstring<CharT> const & chars) {  auto first{ text.find_first_not_of(chars) };
 return text.substr(first, text.size() - first);
}



template<typename CharT> inline tstring<CharT> trimright(tstring<CharT> const &text,  tstring<CharT> const &chars) {  auto last{ text.find_last_not_of(chars) };
 return text.substr(0, last + 1);
}



To remove characters from a string, use std::remove_if() and std::basic_ string::erase():



template<typename CharT> inline tstring<CharT> remove(tstring<CharT> text,  CharT const ch) {  auto start = std::remove_if(  std::begin(text), std::end(text),  [=](CharT const c) {return c == ch; });
 text.erase(start, std::end(text));
 return text;
}



To split a string based on a specif i ed delimiter, use std::getline() to read from an std::basic_stringstream initialized with the content of the string. 
The tokens extracted from the stream are pushed into a vector of strings:



template<typename CharT> inline std::vector<tstring<CharT>> split  (tstring<CharT> text, CharT const delimiter) {  auto sstr = tstringstream<CharT>{ text };
 auto tokens = std::vector<tstring<CharT>>{};
 auto token = tstring<CharT>{};



while (std::getline(sstr, token, delimiter))  {  if (!token.empty()) tokens.push_back(token);
 }  return tokens;
}



How it works...



To implement the utility functions from the library, we have two options:



• Functions would modify a string passed by a reference



• Functions would not alter the original string but return a new string



The second option has the advantage that it preserves the original string, which may be helpful in many cases. Otherwise, in those cases, you would fi rst have to make a copy of the string and alter the copy. The implementation provided in this recipe takes the second approach.



Verifying the format of a string using regular expressions



Regular expressions are a language intended for performing pattern matching and replacements in texts. C++11 provides support for regular expressions within the standard library through a set of classes, algorithms, and iterators available in the header <regex>.



A description of regular expressions syntax and standards is beyond the purpose of this book; if you are not familiar with regular expressions, it is recommended that you read more about them before continuing with the recipes that focus on regular expressions. Good online resources for learning, building, and debugging regular expressions can be found at https://regexr.com and https:// regex101.com.



How to do it...



In order to verify that a string matches a regular expression, perform the following steps:



1. Include the headers <regex> and <string> and the namespace std::string_ literals for C++14 standard user-def i ned literals for strings:



#include <regex> #include <string> using namespace std::string_literals;



2. Use raw string literals to specify the regular expression to avoid escaping backslashes (which can occur frequently). The following regular expression validates most email formats:



auto pattern {R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s};



3. Create an std::regex/std::wregex object (depending on the character set that is used) to encapsulate the regular expression:



auto rx = std::regex{pattern};



4. To ignore casing or specify other parsing options, use an overloaded constructor that has an extra parameter for regular expression fl ags:



auto rx = std::regex{pattern, std::regex_constants::icase};



5. Use std::regex_match() to match the regular expression with an entire string:



auto valid = std::regex_match("marius@domain.com"s, rx);



How it works...



Considering the problem of verifying the format of email addresses, even though this may look like a trivial problem, in practice, it is hard to fi nd a simple regular expression that covers all the possible cases for valid email formats. In this recipe, we will not try to fi nd that ultimate regular expression, but rather apply a regular expression that is good enough for most cases. The regular expression we will use for this purpose is this:



^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$



The following table explains the structure of the regular expression:



Part Description ^ Start of string.
[A-Z0-9._%+-]+ At least one character in the range A-Z, 0-9, or one of -, %, +, or - that represents the local part of the email address.
@ The character @.
[A-Z0-9.-]+ At least one character in the range A-Z, 0-9, or one of -, %, +, or - that represents the hostname of the domain part.
\. A dot that separates the domain hostname and label.
[A-Z]{2,} The DNS label of a domain that can have between 2 and 63 characters.
$ End of the string.



Bear in mind that, in practice, a domain name is composed of a hostname followed by a dot-separated list of DNS labels. Examples include localhost, gmail.com and yahoo.co.uk. This regular expression we are using does not match domains without DNS labels, such as localhost (an email, such as root@localhost, is a valid email). The domain name can also be an IP address specif i ed in brackets, such as [192.168.100.11] (as in john.doe@[192.168.100.11]). Email addresses containing such domains will not match the regular expression def i ned previously. Even though these rather rare formats will not be matched, the regular expression can cover most email formats.



We fi rst construct an std::regex object to encapsulate the regular expression indicated with the raw string literal. Using raw string literals is helpful because it avoids escaping backslashes, which are used for escape characters in regular expressions too. The function then calls std::regex_match(), passing the input text and the regular expression:



bool is_valid_email_format(std::string const & email) {  auto pattern {R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s};
 auto rx = std::regex{pattern, std::regex_constants::icase};
 return std::regex_match(email, rx);
}



The std::regex_match() method tries to match the regular expression against the entire string. If successful, it returns true; otherwise, it returns false:



auto ltest = [](std::string const & email) {  std::cout << std::setw(30) << std::left  << email << " : "



<< (is_valid_email_format(email) ?
 "valid format" : "invalid format")  << '\n';
};
ltest("JOHN.DOE@DOMAIN.COM"s); // valid format ltest("JOHNDOE@DOMAIL.CO.UK"s); // valid format ltest("JOHNDOE@DOMAIL.INFO"s); // valid format ltest("J.O.H.N_D.O.E@DOMAIN.INFO"s); // valid format ltest("ROOT@LOCALHOST"s); // invalid format ltest("john.doe@domain.com"s); // invalid format



Instead of complicating the regular expression with additional valid characters (such as [A-Za-z0-9._%+-]), we can specify that the match can ignore this case. This can be done with an additional parameter to the constructor of the std::basic_regex class. The available constants for this purpose are def i ned in the regex_constants namespace. The following slight change to is_valid_email_format() will make it ignore the case and allow emails with both lowercase and uppercase letters to correctly match the regular expression:



bool is_valid_email_format(std::string const & email) {  auto rx = std::regex{  R"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s,  std::regex_constants::icase};
 return std::regex_match(email, rx);
}



This is_valid_email_format() function is pretty simple, and if the regular expression was provided as a parameter, along with the text to match, it could be used for matching anything. However, it would be nice to be able to handle not only multi-byte strings (std::string), but also wide strings (std::wstring), with a single function. This can be achieved by creating a function template where the character type is provided as a template parameter:



template <typename CharT>



using tstring = std::basic_string<CharT, std::char_traits<CharT>,  std::allocator<CharT>>;



template <typename CharT> bool is_valid_format(tstring<CharT> const & pattern,  tstring<CharT> const & text) {  auto rx = std::basic_regex<CharT>{  pattern, std::regex_constants::icase };
 return std::regex_match(text, rx);
}



We start by creating an alias template for std::basic_string in order to simplify its use. The new is_valid_format() function is a function template very similar to our implementation of is_valid_email(). However, we now use std::basic_ regex<CharT> instead of the typedef std::regex, which is std::basic_regex<char>, and the pattern is provided as the fi rst argument. We now implement a new function called is_valid_email_format_w() for wide strings that relies on this function template. The function template, however, can be reused for implementing other validations, such as if a license plate has a particular format:



bool is_valid_email_format_w(std::wstring const & text) {  return is_valid_format(  LR"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$)"s,  text);
}



auto ltest2 = [](auto const & email) {  std::wcout << std::setw(30) << std::left  << email << L" : "  << (is_valid_email_format_w(email) ? L"valid" : L"invalid")  << '\n';
};



ltest2(L"JOHN.DOE@DOMAIN.COM"s); // valid ltest2(L"JOHNDOE@DOMAIL.CO.UK"s); // valid ltest2(L"JOHNDOE@DOMAIL.INFO"s); // valid ltest2(L"J.O.H.N_D.O.E@DOMAIN.INFO"s); // valid ltest2(L"ROOT@LOCALHOST"s); // invalid ltest2(L"john.doe@domain.com"s); // valid



The std::regex_match() method has, in fact, several overloads, and some of them have a parameter that is a reference to an std::match_results object to store the result of the match. If there is no match, then std::match_results is empty and its size is 0. Otherwise, if there is a match, the std::match_results object is not empty and its size is 1, plus the number of matched subexpressions.



The following version of the function uses the mentioned overloads and returns the matched subexpressions in an std::smatch object. Note that the regular expression is changed as three caption groups are def i ned—one for the local part, one for the hostname part of the domain, and one for the DNS label. If the match is successful, then the std::smatch object will contain four submatch objects: the fi rst to match the entire string, the second for the fi rst capture group (the local part), the third for the second capture group (the hostname), and the fourth for the third and last capture group (the DNS label). The result is returned in a tuple, where the fi rst item actually indicates success or failure:



std::tuple<bool, std::string, std::string, std::string> is_valid_email_format_with_result(std::string const & email) {  auto rx = std::regex{  R"(^([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,})$)"s,  std::regex_constants::icase };
 auto result = std::smatch{};
 auto success = std::regex_match(email, result, rx);
 return std::make_tuple(  success,  success ? result[1].str() : ""s,  success ? result[2].str() : ""s,  success ? result[3].str() : ""s);
}



Following the preceding code, we use C++17 structured bindings to unpack the content of the tuple into named variables:



auto ltest3 = [](std::string const & email) {  auto [valid, localpart, hostname, dnslabel] =  is_valid_email_format_with_result(email);
 std::cout << std::setw(30) << std::left



<< email << " : "  << std::setw(10) << (valid ? "valid" : "invalid")  << "local=" << localpart  << ";domain=" << hostname  << ";dns=" << dnslabel  << '\n';
};



ltest3("JOHN.DOE@DOMAIN.COM"s);
ltest3("JOHNDOE@DOMAIL.CO.UK"s);
ltest3("JOHNDOE@DOMAIL.INFO"s);
ltest3("J.O.H.N_D.O.E@DOMAIN.INFO"s);
ltest3("ROOT@LOCALHOST"s);
ltest3("john.doe@domain.com"s);



There are multiple versions of regular expressions, and the C++ standard library supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and egrep (grep with the option -E). The default grammar used is ECMAScript, and in order to use another, you have to explicitly specify the grammar when def i ning the regular expression. In addition to specifying the grammar, you can also specify parsing options, such as matching by ignoring the case.



The standard library provides more classes and algorithms than what we have seen so far. The main classes available in the library are as follows (all of them are class templates and, for convenience, typedefs are provided for different character types):



• The class template std::basic_regex def i nes the regular expression object:



typedef basic_regex<char> regex;
typedef basic_regex<wchar_t> wregex;



• The class template std::sub_match represents a sequence of characters that matches a capture group; this class is actually derived from std::pair, and its first and second members represent iterators to the fi rst and the one-past-end characters in the match sequence. If there is no match sequence, the two iterators are equal:



typedef sub_match<const char *> csub_match;
typedef sub_match<const wchar_t *> wcsub_match;
typedef sub_match<string::const_iterator> ssub_match;
typedef sub_match<wstring::const_iterator> wssub_match;



• The class template std::match_results is a collection of matches; the fi rst element is always a full match in the target, while the other elements are matches of subexpressions:



typedef match_results<const char *> cmatch;
typedef match_results<const wchar_t *> wcmatch;
typedef match_results<string::const_iterator> smatch;
typedef match_results<wstring::const_iterator> wsmatch;



The algorithms available in the regular expressions standard library are as follows:



• std::regex_match(): This tries to match a regular expression (represented by an std::basic_regex instance) to an entire string.



• std::regex_search(): This tries to match a regular expression (represented by an std::basic_regex instance) to a part of a string (including the entire string).



• std::regex_replace(): This replaces matches from a regular expression according to a specif i ed format.



The iterators available in the regular expressions standard library are as follows:



• std::regex_interator: A constant forward iterator used to iterate through the occurrences of a pattern in a string. It has a pointer to an std::basic_ regex that must live until the iterator is destroyed. Upon creation and when incremented, the iterator calls std::regex_search() and stores a copy of the std::match_results object returned by the algorithm.



• std::regex_token_iterator: A constant forward iterator used to iterate through the submatches of every match of a regular expression in a string. 
Internally, it uses a std::regex_iterator to step through the submatches. 
Since it stores a pointer to an std::basic_regex instance, the regular expression object must live until the iterator is destroyed.



It should be mentioned that the standard regex library has poorer performance compared to other implementations (such as Boost.Regex) and does not support Unicode. Moreover, it could be argued that the API itself is cumbersome to use.



Parsing the content of a string using regular expressions



The library provides another algorithm called std::regex_search() that matches a regular expression against any part of a string, and not only the entire string, as regex_match() does. This function, however, does not allow us to search through all the occurrences of a regular expression in an input string. For this purpose, we need to use one of the iterator classes available in the library.



In this recipe, you will learn how to parse the content of a string using regular expressions. For this purpose, we will consider the problem of parsing a text fi le containing name-value pairs. Each such pair is def i ned on a different line and has the format name = value, but lines starting with a # represent comments and must be ignored. The following is an example:



#remove # to uncomment a line timeout=120 server = 127.0.0.1 #retrycount=3



In the following examples, text is a variable that's def i ned as follows:



auto text {  R"(  #remove # to uncomment a line  timeout=120  server = 127.0.0.1  #retrycount=3  )"s};



The sole purpose of this is to simplify our snippets, although in a real-world example, you will probably be reading the text from a fi le or other source.



In order to search for occurrences of a regular expression through a string, you should do the following:



1. Include the headers <regex> and <string> and the namespace std::string_ literals for C++14 standard user-def i ned literals for strings:



#include <regex> #include <string> using namespace std::string_literals;



2. Use raw string literals to specify a regular expression in order to avoid escaping backslashes (which can occur frequently). The following regular expression validates the fi le format proposed earlier:



auto pattern {R"(^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,\-:]*)$)"s};



3. Create an std::regex/std::wregex object (depending on the character set that is used) to encapsulate the regular expression:



auto rx = std::regex{pattern};



4. To search for the fi rst occurrence of a regular expression in a given text, use the general-purpose algorithm std::regex_search() (example 1):



auto match = std::smatch{};
if (std::regex_search(text, match, rx)) {  std::cout << match[1] << '=' << match[2] << '\n';
}



5. To fi nd all the occurrences of a regular expression in a given text, use the iterator std::regex_iterator (example 2):



auto end = std::sregex_iterator{};
for (auto it=std::sregex_iterator{ std::begin(text),  std::end(text), rx };
 it != end; ++it) {  std::cout << '\'' << (*it)[1] << "'='"  << (*it)[2] << '\'' << '\n';
}



6. To iterate through all the subexpressions of a match, use the iterator std::regex_token_iterator (example 3):



auto end = std::sregex_token_iterator{};
for (auto it = std::sregex_token_iterator{  std::begin(text), std::end(text), rx };
 it != end; ++it) {  std::cout << *it << '\n';
}



How it works...



A simple regular expression that can parse the input fi le shown earlier may look like this:



^(?!#)(\w+)\s*=\s*([\w\d]+[\w\d._,\-:]*)$



This regular expression is supposed to ignore all lines that start with a #; for those that do not start with #, match a name followed by the equals sign and then a value that can be composed of alphanumeric characters and several other characters (underscore, dot, comma, and so on). The exact meaning of this regular expression is explained as follows:



Part Description ^ Start of line.
(?!#) A negative lookahead that makes sure that it is not possible to match the # character.
(\w)+ A capturing group representing an identif i er of at least a one-word character.
\s* Any whitespaces.
= Equals sign.
\s* Any whitespaces.
([\w\d]+[\w\d._,\-:]*) A capturing group representing a value that starts with an alphanumeric character, but can also contain a dot, comma, backslash, hyphen, colon, or an underscore.
$ End of line.



We can use std::regex_search() to search for a match anywhere in the input text. 
This algorithm has several overloads, but in general, they work in the same way. You must specify the range of characters to work through, an output std::match_results object that will contain the result of the match, and an std::basic_regex object representing the regular expression and matching fl ags (which def i ne the way the search is done). The function returns true if a match was found or false otherwise.



In the fi rst example from the previous section (see the fourth list item), match is an instance of std::smatch that is a typedef of std::match_results with string::const_ iterator as the template type. If a match was found, this object will contain the matching information in a sequence of values for all matched subexpressions. 
The submatch at index 0 is always the entire match. The submatch at index 1 is the fi rst subexpression that was matched, the submatch at index 2 is the second subexpression that was matched, and so on. Since we have two capturing groups (which are subexpressions) in our regular expression, the std::match_results will have three submatches in the event of success. The identif i er representing the name is at index 1, and the value after the equals sign is at index 2. Therefore, this code only prints the following:
--
output:
timeout=120



The std::regex_search() algorithm is not able to iterate through all the possible matches in a piece of text. To do that, we need to use an iterator. std::regex_ iterator is intended for this purpose. It allows not only iterating through all the matches, but also accessing all the submatches of a match.



The iterator actually calls std::regex_search() upon construction and on each increment, and it remembers the resulting std::match_results from the call. The default constructor creates an iterator that represents the end of the sequence and can be used to test when the loop through the matches should stop.



In the second example from the previous section (see the fi fth list item), we fi rst create an end-of-sequence iterator, and then we start iterating through all the possible matches. When constructed, it will call std::regex_match(), and if a match is found, we can access its results through the current iterator. This will continue until no match is found (the end of the sequence). This code will print the following output:
--
output:
'timeout'='120'
'server'='127.0.0.1'



An alternative to std::regex_iterator is std::regex_token_iterator. This works similar to the way std::regex_iterator works and, in fact, it contains such an iterator internally, except that it enables us to access a particular subexpression from a match. This is shown in the third example in the How to do it... section (see the sixth list item). We start by creating an end-of-sequence iterator and then loop through the matches until the end-of-sequence is reached. In the constructor we used, we did not specify the index of the subexpression to access through the iterator; therefore, the default value of 0 is used. This means this program will print all the matches:
--
output:
timeout=120
server = 127.0.0.1



If we wanted to access only the fi rst subexpression (this means the names in our case), all we had to do was specify the index of the subexpression in the constructor of the token iterator, as shown here:



auto end = std::sregex_token_iterator{};
for (auto it = std::sregex_token_iterator{ std::begin(text),  std::end(text), rx, 1 };
 it != end; ++it) {  std::cout << *it << '\n';
}



This time, the output that we get contains only the names. This is shown in the following image:
--
timeout
server



An interesting thing about the token iterator is that it can return the unmatched parts of the string if the index of the subexpressions is -1, in which case it returns an std::match_results object that corresponds to the sequence of characters between the last match and the end of the sequence:



auto end = std::sregex_token_iterator{};
for (auto it = std::sregex_token_iterator{ std::begin(text),  std::end(text), rx, -1 };
 it != end; ++it) {  std::cout << *it << '\n';
}



This program will output the following:
--
#remove # to uncomment a line




#retrycount=3



Please note that the empty lines in the output correspond to empty tokens.



Replacing the content of a string using regular expressions



How to do it...



In order to perform text transformations using regular expressions, you should perform the following:



• Include <regex> and <string> and the namespace std::string_literals for C++14 standard user-def i ned literals for strings:



#include <regex> #include <string> using namespace std::string_literals;



• Use the std::regex_replace() algorithm with a replacement string as the third argument. Consider this example: replace all words composed of exactly three characters that are either a, b, or c with three hyphens:



auto text{"abc aa bca ca bbbb"s};
auto rx = std::regex{ R"(\b[a|b|c]{3}\b)"s };
auto newtext = std::regex_replace(text, rx, "---"s);



• Use the std::regex_replace() algorithm with match identif i ers pref i xed with a $ for the third argument. For example, replace names in the format "lastname, fi rstname" with names in the format "f i rstname lastname", as follows:



auto text{ "bancila, marius"s };
auto rx = std::regex{ R"((\w+),\s*(\w+))"s };
auto newtext = std::regex_replace(text, rx, "$2 $1"s);



How it works...



The std::regex_replace() algorithm has several overloads with different types of parameters, but the meaning of the parameters is as follows:



• The input string on which the replacement is performed.



• An std::basic_regex object that encapsulates the regular expression used to identify the parts of the strings to be replaced.



• The string format used for replacement.



• Optional matching fl ags.



The return value is, depending on the overload used, either a string or a copy of the output iterator provided as an argument. The string format used for replacement can either be a simple string or a match identif i er, indicated with a $ pref i x:



• $& indicates the entire match.



• $1, $2, $3, and so on indicate the fi rst, second, and third submatches, and so on.



• $` indicates the part of the string before the fi rst match.



• $' indicates the part of the string after the last match.



In the fi rst example shown in the How to do it... section, the initial text contains two words made of exactly three a, b, and c characters, abc and bca. The regular expression indicates an expression of exactly three characters between word boundaries. This means a subtext, such as bbbb, will not match the expression. 
The result of the replacement is that the string text will be --- aa --- ca bbbb.



Additional fl ags for the match can be specif i ed for the std::regex_replace() algorithm. By default, the matching fl ag is std::regex_constants::match_default, which basically specif i es ECMAScript as the grammar used for constructing the regular expression. If we want, for instance, to replace only the fi rst occurrence, then we can specify std::regex_constants::format_first_only. In the following example, the result is --- aa bca ca bbbb as the replacement stops after the fi rst match is found:



auto text{ "abc aa bca ca bbbb"s };
auto rx = std::regex{ R"(\b[a|b|c]{3}\b)"s };
auto newtext = std::regex_replace(text, rx, "---"s,  std::regex_constants::format_first_only);



The replacement string, however, can contain special indicators for the whole match, a particular submatch, or the parts that were not matched, as explained earlier. In the second example shown in the How to do it... section, the regular expression identif i es a word of at least one character, followed by a comma and possible white spaces, and then another word of at least one character. The fi rst word is supposed to be the last name, while the second word is supposed to be the fi rst name. The replacement string is in the $2 $1 format. This is an instruction that's used to replace the matched expression (in this example, the entire original string) with another string formed of the second submatch, followed by a space and then the fi rst submatch.



In this case, the entire string was a match. In the following example, there will be multiple matches inside the string, and they will all be replaced with the indicated string. In this example, we are replacing the indef i nite article a when preceding a word that starts with a vowel (this, of course, does not cover words that start with a vowel sound) with the indef i nite article an:



auto text{"this is a example with a error"s};
auto rx = std::regex{R"(\ba ((a|e|i|u|o)\w+))"s};
auto newtext = std::regex_replace(text, rx, "an $1");



The regular expression identif i es the letter a as a single word (\b indicates a word boundary, so \ba means a word with a single letter, a), followed by a space and a word of at least two characters starting with a vowel. When such a match is identif i ed, it is replaced with a string formed of the fi xed string an, followed by a space and the fi rst subexpression of the match, which is the word itself. In this example, the newtext string will be this is an example with an error.



Apart from the identif i ers of the subexpressions ($1, $2, and so on), there are other identif i ers for the entire match ($&), the part of the string before the fi rst match ($`), and the part of the string after the last match ($'). In the last example, we change the format of a date from dd.mm.yyyy to yyyy.mm.dd, but also show the matched parts:



auto text{"today is 1.06.2016!!"s};
auto rx =  std::regex{R"((\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4}))"s};
// today is 2016.06.1!!
auto newtext1 = std::regex_replace(text, rx, R"($5$4$3$2$1)");
// today is [today is ][1.06.2016][!!]!!
auto newtext2 = std::regex_replace(text, rx, R"([$`][$&][$'])");



The regular expression matches a one- or two-digit number followed by a dot, hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen, or slash; and lastly a four-digit number.



For newtext1, the replacement string is $5$4$3$2$1; this means year, followed by the second separator, then month, the fi rst separator, and fi nally day. Therefore, for the input string today is 1.06.2016!, the result is today is 2016.06.1!!.



For newtext2, the replacement string is [$`][$&][$']; this means the part before the fi rst match, followed by the entire match, and fi nally the part after the last match, are in square brackets. However, the result is not [!!][1.06.2016][today is ] as you perhaps might expect at fi rst glance, but today is [today is ][1.06.2016] [!!]!!. The reason for this is that what is replaced is the matched expression, and, in this case, that is only the date (1.06.2016). This substring is replaced with another string formed of all the parts of the initial string.



Using string_view instead of constant string references



When working with strings, temporary objects are created all the time, even if you might not be really aware of it. Many times, these temporary objects are irrelevant and only serve the purpose of copying data from one place to another (for example, from a function to its caller). This represents a performance issue because they require memory allocation and data copying, which should be avoided. 
For this purpose, the C++17 standard provides a new string class template called std::basic_string_view that represents a non-owning constant reference to a string (that is, a sequence of characters).



The string_view class is available in the namespace std in the string_view header.



How to do it...



You should use std::string_view to pass a parameter to a function (or return a value from a function), instead of std::string const &, unless your code needs to call other functions that take std::string parameters (in which case, conversions would be necessary):



std::string_view get_filename(std::string_view str) {  auto const pos1 {str.find_last_of('')};
 auto const pos2 {str.find_last_of('.')};
 return str.substr(pos1 + 1, pos2 - pos1 - 1);
} char const file1[] {R"(c:\test\example1.doc)"};
auto name1 = get_filename(file1);
std::string file2 {R"(c:\test\example2)"};
auto name2 = get_filename(file2);
auto name3 = get_filename(std::string_view{file1, 16});



How it works...



Before we look at how the new string type works, let's consider the following example of a function that is supposed to extract the name of a fi le without its extension. This is basically how you would write the function from the previous section before C++17:



std::string get_filename(std::string const & str) {  auto const pos1 {str.find_last_of('\\')};
 auto const pos2 {str.find_last_of('.')};
 return str.substr(pos1 + 1, pos2 - pos1 - 1);
} auto name1 = get_filename(R"(c:\test\example1.doc)"); // example1 auto name2 = get_filename(R"(c:\test\example2)"); // example2 if(get_filename(R"(c:\test\_sample_.tmp)").front() == '_') {}



The get_filename() function is relatively simple. It takes a constant reference to an std::string and identif i es a substring bounded by the last fi le separator and the last dot, which basically represents a fi lename without an extension (and without folder names).



The problem with this code, however, is that it creates one, two, or possibly even more temporaries, depending on the compiler optimizations. The function parameter is a constant std::string reference, but the function is called with a string literal, which means std::string needs to be constructed from the literal. These temporaries need to allocate and copy data, which is both time- and resource-consuming. In the last example, all we want to do is check whether the fi rst character of the fi lename is an underscore, but we create at least two temporary string objects for that purpose.



The std::basic_string_view class template is intended to solve this problem. This class template is very similar to std::basic_string, with the two having almost the same interface. The reason for this is that std::basic_string_view is intended to be used instead of a constant reference to an std::basic_string without further code changes. Just like with std::basic_string, there are specializations for all types of standard characters:



typedef basic_string_view<char> string_view;
typedef basic_string_view<wchar_t> wstring_view;
typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;



The std::basic_string_view class template def i nes a reference to a constant contiguous sequence of characters. As the name implies, it represents a view and cannot be used to modify the reference sequence of characters. An std::basic_ string_view object has a relatively small size because all that it needs is a pointer to the fi rst character in the sequence and the length. It can be constructed not only from an std::basic_string object but also from a pointer and a length, or from a null-terminated sequence of characters (in which case, it will require an initial traversal of the string in order to fi nd the length). Therefore, the std::basic_string_view class template can also be used as a common interface for multiple types of strings (as long as data only needs to be read). On the other hand, converting from an std::basic_ string_view to an std::basic_string is not possible.



You must explicitly construct an std::basic_string object from a std::basic_ string_view, as shown in the following example:



std::string_view sv{ "demo" };
std::string s{ sv };



Passing std::basic_string_view to functions and returning std::basic_string_view still creates temporaries of this type, but these are small-sized objects on the stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore, they should incur fewer performance costs than allocating heap space and copying data.



In addition to the methods that are identical to those available in std::basic_string, the std::basic_string_view has two more:



• remove_prefix(): Shrinks the view by incrementing the start with N characters and decrementing the length with N characters.



• remove_suffix(): Shrinks the view by decrementing the length with N characters.



The two member functions are used in the following example to trim an std::string_view from spaces, both at the beginning and the end. The implementation of the function fi rst looks for the fi rst element that is not a space and then for the last element that is not a space. Then, it removes from the end everything after the last non-space character, and from the beginning everything until the fi rst non-space character. The function returns the new view, trimmed at both ends:



std::string_view trim_view(std::string_view str) {  auto const pos1{ str.find_first_not_of(" ") };
 auto const pos2{ str.find_last_not_of(" ") };
 str.remove_suffix(str.length() - pos2 - 1);
 str.remove_prefix(pos1);
 return str;
--
}



auto sv1{ trim_view("sample") };
auto sv2{ trim_view(" sample") };
auto sv3{ trim_view("sample ") };
auto sv4{ trim_view(" sample ") };
std::string s1{ sv1 };
std::string s2{ sv2 };
std::string s3{ sv3 };
std::string s4{ sv4 };



When using std::basic_string_view, you must be aware of two things: you cannot change the underlying data referred to by a view and you must manage the lifetime of the data, as the view is a non-owning reference.



Formatting text with std::format



The C++ language has two ways of formatting text: the printf family of functions and the I/O streams library. The printf functions are inherited from C and provide a separation of the formatting text and the arguments. The streams library provides safety and extensibility and is usually recommended over printf functions, but is, in general, slower. The C++20 standard proposes a new formatting library alternative for output formatting, which is similar in form to printf but safe and extensible and is intended to complement the existing streams library. In this recipe, we will learn how to use the new functionalities instead of the printf functions or the streams library.



The new formatting library is available in the header <format>. You must include this header for the following samples to work.



How to do it...



The std::format() function formats its arguments according to the provided formatting string. You can use it as follows:



• Provide empty replacement fi elds, represented by {}, in the format string for each argument:



auto text = std::format("{} is {}", "John", 42);



• Specify the 0-based index of each argument in the argument list inside the replacement fi eld, such as {0}, {1}, and so on. The order of the arguments is not important, but the index must be valid:



auto text = std::format("{0} is {1}", "John", 42);



• Control the output text with format specif i ers provided in the replacement fi eld after a colon (:). For basic and string types, this is a standard format specif i cation. For chrono types, this is a chrono format specif i cation:



auto text = std::format("{0} hex is {0:08X}", 42);
auto now = std::chrono::system_clock::now();
auto time = std::chrono::system_clock::to_time_t(now);
auto text = std::format("Today is {:%Y-%m-%d}", *std::localtime(&time));



You can also write the arguments in an out format using an iterator with either std::format_to() or std::format_to_n(), as follows:



• Write to a buffer, such as an std::string or std::vector<char>, using std::format_n() and using the std::back_inserter() helper function:



std::vector<char> buf;
std::format_to(std::back_inserter(buf), "{} is {}", "John", 42);



Use std::formatted_size() to retrieve the number of characters necessary to store the formatted representation of the arguments:



auto size = std::formatted_size("{} is {}", "John", 42);
std::vector<char> buf(size);
std::format_to(buf.data(), "{} is {}", "John", 42);



To limit the number of characters written to the output buffer, you can use std::format_to_n(), which is similar to std::format_to() but writes, at most, n characters:



char buf[100];
auto result = std::format_to_n(buf, sizeof(buf), "{} is {}", "John", 42);



How it works...



The std::format() function has multiple overloads. You can specify the format string either as a string view or a wide string view, with the function returning either an std::string or an std::wstring. You can also specify, as the fi rst argument, an std::locale, which is used for locale-specif i c formatting. The function overloads are all variadic function templates, which means you can specify any number of arguments after the format.



The format string consists of ordinary characters, replacement fi elds, and escape sequences. The escape sequences are {{ and }} and are replaced with { and } in the output. A replacement fi eld is provided within curly brackets {}. It can optionally contain a non-negative number, representing the 0-based index of the argument to be formatted, and a colon (:), followed by a format specif i er. If the format specif i er is invalid, an exception of the type std::format_error is thrown.



In a similar manner, std::format_to() has multiple overloads, just like std::format(). The difference between these two is that std::format_to() always takes an iterator to the output buffer as the fi rst argument and returns an iterator past the end of the output range (and not a string as std::format() does). On the other hand, std::format_to_n() has one more parameter than std::format_to(). 
Its second parameter is a number representing the maximum number of characters to be written to the buffer.



The following listing shows the signature of the simplest overload of each of these three function templates:



template<class... Args> std::string format(std::string_view fmt, const Args&... args);
template<class OutputIt, class... Args> OutputIt format_to(OutputIt out,



std::string_view fmt, const Args&... args);
template<class OutputIt, class... Args> std::format_to_n_result<OutputIt> format_to_n(OutputIt out, std::iter_difference_t<OutputIt> n,  std::string_view fmt, const Args&... args);



When you provide the format string, you can supply argument identif i ers (their 0-based index) or omit them. However, it is illegal to use both. If the indexes are omitted in the replacement fi elds, the arguments are processed in the provided order, and the number of replacement fi elds must not be greater than the number of supplied arguments. If indexes are provided, they must be valid for the format string to be valid.



When a format specif i cation is used, then:



• For basic types and string types, it is considered to be a standard format specif i cation.



• For chrono types, it is considered to be a chrono format specif i cation.



• For user-def i ned types, it is def i ned by a user-def i ned specialization of the std::formatter class for the desired type.



The standard format specif i cation is based on the format specif i cation in Python and has the following syntax:



fill-and-align(optional) sign(optional) #(optional) 0(optional) width(optional) precision(optional) L(optional) type(optional)



These syntax parts are brief l y described here.



fill-and-align is an optional fi ll character, followed by one of the align options:



• <: Forces the fi eld to be left-aligned with the available space.



• >: Forces the fi eld to be right-aligned with the available space.



• ^: Forces the fi eld to be centered with the available space. To do so, it will insert n/2 characters to the left and n/2 characters to the right:



auto t1 = std::format("{:5}", 42); // " 42" auto t2 = std::format("{:5}", 'x'); // "x " auto t3 = std::format("{:*<5}", 'x'); // "x****" auto t4 = std::format("{:*>5}", 'x'); // "****x" auto t5 = std::format("{:*^5}", 'x'); // "**x**" auto t6 = std::format("{:5}", true); // "true "



sign, #, and 0 are only valid when a number (either an integer or a fl oating-point) is used. The sign can be one of:



• +: Specif i es that the sign must be used for both negative and positive numbers.



• -: Specif i es that the sign must be used only for negative numbers (which is the implicit behavior).



• A space: Specif i es that the sign must be used for negative numbers and that a leading space must be used for non-negative numbers:



auto t7 = std::format("{0:},{0:+},{0:-},{0: }", 42);
// "42,+42,42, 42" auto t8 = std::format("{0:},{0:+},{0:-},{0: }", -42);
// "-42,-42,-42,-42"



The symbol # causes the alternate form to be used. This can be one of the following:



• For integral types, when binary, octal, or hexadecimal representation is specif i ed, the alternate form adds the pref i x 0b, 0, or 0x to the output.



• For fl oating-point types, the alternate form causes a decimal-point character to always be present in the formatted value, even if no digits follow it. In addition, when g or G are used, the trailing zeros are not removed from the output.



The digit 0 specif i es that leading zeros should be outputted to the fi eld width, except when the value of a fl oating-point type is inf i nity or NaN. When present alongside an align option, the specif i er 0 is ignored:



auto t9 = std::format("{:+05d}", 42); // "+0042" auto t10 = std::format("{:#05x}", 42); // "0x02a" auto t11 = std::format("{:<05}", -42); // "-42 "



width specif i es the minimum fi eld width and can be either a positive decimal number or a nested replacement fi eld. The precision fi eld indicates the precision for fl oating-point types or, for string types, how many characters will be used from the string. It is specif i ed with a dot (.), followed by a non-negative decimal number or a nested replacement fi eld.



Locale-specif i c formatting is specif i ed with the uppercase L and causes the locale-specif i c form to be used. This option is only available for arithmetic types.



The optional type determines how the data will be presented in the output. 
The available string presentation types are shown in the following table:
--
screenshot



The chrono format specif i cation has the following form:



fill-and-align(optional) width(optional) precision(optional) chrono-spec(optional)



The fill-and-align, width, and precision fi elds have the same meaning as in the standard format specif i cation, described previously. The precision is only valid for std::chrono::duration types when the representation type is a fl oating-point type. Using it in other cases throws an std::format_error exception.



The chrono specif i cation can be empty, in which case the argument is formatted as if by streaming it to an std::stringstream and copying the result string. Alternatively, it can consist of a series of conversion specif i ers and ordinary characters. Some of these format specif i ers are presented in the following table:



Conversion specif i er Description %% Writes a literal % character.
%n Writes a newline character.
%t Writes a horizontal tab character.
%Y Writes the year as a decimal number. If the result is less than four digits, it is left-padded with 0 to four digits.
%m Writes the month as a decimal number (January is 01). If the result is a single digit, it is pref i xed with 0.
%d Writes the day of month as a decimal number. If the result is a single decimal digit, it is pref i xed with 0.
%w Writes the weekday as a decimal number (0-6), where Sunday is 0.
%D Equivalent to %m/%d/%y.
%F Equivalent to %Y-%m-%d.
%H Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is pref i xed with 0.
%I Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is pref i xed with 0.



%M Writes the minute as a decimal number. If the result is a single digit, it is pref i xed with 0.
%S Writes the second as a decimal number. If the number of seconds is less than 10, the result is pref i xed with 0.
%R Equivalent to %H:%M.
%T Equivalent to %H:%M:%S.
%X Writes the locale's time representation.



The complete list of format specif i ers for the chrono library can be consulted at https://en.cppreference.com/w/cpp/chrono/system_clock/formatter.



Using std::format with user-def i ned types



The C++20 formatting library is a modern alternative to using printf-like functions or the I/O streams library, which it actually complements. Although the standard provides default formatting for basic types, such as integral and fl oating-point types, bool, character types, strings, and chrono types, the user can create custom specialization for user-def i ned types. In this recipe, we will learn how to do that.



In the examples that we'll be showing here, we will use the following class:



struct employee {  int id;
 std::string firstName;
 std::string lastName;
};



How to do it...



To enable formatting using the new formatting library for user-def i ned types, you must do the following:



• Def i ne a specialization of the std::formatter<T, CharT> class in the std namespace.



• Implement the parse() method to parse the portion of the format string corresponding to the current argument. If the class inherits from another formatter, then this method can be omitted.



• Implement the format() method to format the argument and write the output via format_context.



For the employee class listed here, a formatter that formats employee to the form [42] John Doe (that is [id] firstName lastName) can be implemented as follows:



template <> struct std::formatter<employee> {  constexpr auto parse(format_parse_context& ctx)  {  return ctx.begin();
 }  auto format(employee const & value, format_context& ctx) {  return std::format_to(ctx.out(),  "[{}] {} {}",  e.id, e.firstName, e.lastName);
 } };



How it works...



The formatting library uses the std::formatter<T, CharT> class template to def i ne formatting rules for a given type. Built-in types, string types, and chrono types have formatters provided by the library. These are implemented as specializations of the std::formatter<T, CharT> class template.



This class has two methods:



• parse(), which takes a single argument of the type std::basic_format_ parse_context<CharT> and parses the format's specif i cation for the type T, provided by the parse context. The result of the parsing is supposed to be stored in member fi elds of the class. If the parsing succeeds, this function should return a value of the type std::basic_format_parse_ context<CharT>::iterator, which represents the end of the format specif i cation. If the parsing fails, the function should throw an exception of the type std::format_error to provide details about the error.



• format(), which takes two arguments, the fi rst being the object of the type T to format and the second being a formatting context object of the type std::basic_format_context<OutputIt, CharT>. This function should write the output to ctx.out() according to the desired specif i ers (which could be something implicit or the result of parsing the format specif i cation). 
The function must return a value of the type std::basic_format_ context<OutputIt, CharT>::iterator, representing the end of the output.



In the implementation shown here, the parse() function does not do anything other than return an iterator representing the beginning of the format specif i cation. 
The formatting is always done by printing the employee identif i er between square brackets, followed by the fi rst name and the last name, such as in [42] John Doe. 
An attempt to use a format specif i er would result in a runtime exception:



employee e{ 42, "John", "Doe" };
auto s1 = std::format("{}", e); // [42] John Doe auto s2 = std::format("{:L}", e); // error



If you want your user-def i ned types to support format specif i ers, then you must properly implement the parse() method. To show how this can be done, we will support the L specif i er for the employee class. When this specif i er is used, the employee is formatted with the identif i er in square brackets, followed by the last name, a comma, and then the fi rst name, such as in [42] Doe, John:



template<> struct std::formatter<employee> {  bool lexicographic_order = false;
 template <typename ParseContext>  constexpr auto parse(ParseContext& ctx)  {  auto iter = ctx.begin();



auto get_char = [&]() { return iter != ctx.end() ? *iter : 0; };
 if (get_char() == ':') ++iter;
 char c = get_char();
 switch (c)  {  case '}': return ++iter;
 case 'L': lexicographic_order = true; return ++iter;
 case '{': return ++iter;
 default: throw std::format_error("invalid format");
 }  }  template <typename FormatContext>  auto format(employee const& e, FormatContext& ctx)  {  if(lexicographic_order)  return std::format_to(ctx.out(), "[{}] {}, {}",  e.id, e.lastName, e.firstName);
 return std::format_to(ctx.out(), "[{}] {} {}",  e.id, e.firstName, e.lastName);
 } };



With this def i ned, the preceding sample code would work. However, using other format specif i ers, such as A, for example, would still throw an exception:



auto s1 = std::format("{}", e); // [42] John Doe auto s2 = std::format("{:L}", e); // [42] Doe, John auto s3 = std::format("{:A}", e); // error (invalid format)



If you do not need to parse the format specif i er in order to support various options, you could entirely omit the parse() method. However, in order to do so, your std::formatter specialization must derive from another std::formatter class. 
An implementation is shown here:



template<> struct fmt::formatter<employee> : fmt::formatter<char const*> {  template <typename FormatContext>



auto format(employee const& e, FormatContext& ctx)  {  return std::format_to(ctx.out(), "[{}] {} {}",  e.id, e.firstName, e.lastName);
 } };



This specialization for the employee class is equivalent to the fi rst implementation shown earlier in the How to do it... section.

--
Reading books with ReadEra
https://play.google.com/store/apps/details?id=org.readera.premium&hl=en